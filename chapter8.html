
<!DOCTYPE html>
<html>
  <head>
    <title>L.B.Stanza</title>
    <link type="text/css" rel="stylesheet" href="resources/mainstyle.css">
    <link type="text/css" rel="stylesheet" href="resources/documentation.css">
  </head>
  <body>
    <table class="wrap">
      <tr><td colspan="3" class="banner">
        <a href="index.html">Home</a><a href="stanzabyexample.html">Table of Contents</a><a href="chapter7.html">Previous Chapter</a><a href="chapter9.html">Next Chapter</a>
      </td></tr>
      <tr>
        <td class="nav">
          <h1>NAVIGATION</h1>
          <h2><a href="#anchor291">Parametric Polymorphism</a></h2><h3><a href="#anchor73">The Need for Polymorphism</a></h3><h4><a href="#anchor292">The Limitations of the ? Type</a></h4><h3><a href="#anchor74">Explicit Type Arguments</a></h3><h3><a href="#anchor75">Captured Type Arguments</a></h3><h4><a href="#anchor293">Capture Locations</a></h4><h4><a href="#anchor294">Multiple Capture Locations</a></h4><h4><a href="#anchor295">Example: map-list</a></h4><h4><a href="#anchor296">Example: map-both</a></h4><h3><a href="#anchor76">Parametric Types</a></h3><h4><a href="#anchor297">Declaring a Parametric Type</a></h4><h4><a href="#anchor298">Declaring Multis</a></h4><h4><a href="#anchor299">Creating Either Objects</a></h4><h4><a href="#anchor300">Polymorphic Constructor Function</a></h4><h4><a href="#anchor301">Parametric Structs</a></h4><h4><a href="#anchor302">Constructor Function with Captured Arguments</a></h4><h4><a href="#anchor303">When <span style="font-style:italic;">not</span> to Use Captured Arguments</a></h4><h3><a href="#anchor77">Match Expressions and Type Erasure</a></h3><h3><a href="#anchor78">Revisiting Stack</a></h3><h4><a href="#anchor304">Parametric Type Declaration</a></h4><h4><a href="#anchor305">Polymorphic Fundamental Operations</a></h4><h4><a href="#anchor306">Polymorphic Constructor Function</a></h4><h4><a href="#anchor307">Trying It Out</a></h4>
        </td>
        <td class="main">
          <h1 id="anchor291">Parametric Polymorphism</h1><p>This chapter will introduce you to the concept of <span style="font-style:italic;">parametric polymorphism</span> and show you how to parameterize your functions using <span style="font-style:italic;">type arguments</span>, and your types using <span style="font-style:italic;">type parameters</span>. </p><h2 id="anchor73">The Need for Polymorphism</h2><p>Thus far, none of the functions you have written so far have been parameterized by type. Here is an example implementation of a function that reverses a list of integers.</p><pre><code>defn reverse-list (xs:List&lt;Int&gt;) -&gt; List&lt;Int&gt; :<br>&nbsp;&nbsp; if empty?(xs) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xs<br>&nbsp;&nbsp; else :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; append(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reverse-list(tail(xs))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List(head(xs)))</code></pre><p>But notice that it only works on integers. Thus the following does not compile.</p><pre><code>reverse-list(List(&quot;Timon&quot;, &quot;and&quot;, &quot;Pumbaa&quot;))</code></pre><p>It gives this error.</p><pre><code>Cannot call function reverse-list of type List&lt;Int&gt; -&gt; List&lt;Int&gt; <br>with arguments of type (FullList&lt;String&gt;).</code></pre><p>To handle this, we can write an overloaded version of <code>reverse-list</code> that accepts a list of strings.</p><pre><code>defn reverse-list (xs:List&lt;String&gt;) -&gt; List&lt;String&gt; :<br>&nbsp;&nbsp; if empty?(xs) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xs<br>&nbsp;&nbsp; else :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; append(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reverse-list(tail(xs))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List(head(xs)))</code></pre><p>Now <code>reverse-list</code> will work on both integers and strings. So the following</p><pre><code>println(reverse-list(List(1, 2, 3)))<br>println(reverse-list(List(&quot;Timon&quot;, &quot;and&quot;, &quot;Pumbaa&quot;)))</code></pre><p>compiles and prints out</p><pre><code>(3 2 1)<br>(&quot;Pumbaa&quot; &quot;and&quot; &quot;Timon&quot;)</code></pre><p>However, the code for the string version of <code>reverse-list</code> is identical to the integer version, save for its type signature. This is an obvious duplication of effort. Also, this is clearly a subpar solution. What if we next want to reverse a list of characters? It is not practical to define an overloaded version of <code>reverse-list</code> for every type of list we wish to reverse.</p><h3 id="anchor292">The Limitations of the ? Type</h3><p>What we need is the ability to call <code>reverse-list</code> on lists of <span style="font-style:italic;">any</span> type. Well, we&#39;ve already learned about one mechanism that will allow us to do this: the <code>?</code> type. So let&#39;s replace our two overloaded <code>reverse-list</code> functions with a single one that accepts a <code>List&lt;?&gt;</code> as its argument.</p><pre><code>defn reverse-list (xs:List) -&gt; List :<br>&nbsp;&nbsp; if empty?(xs) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xs<br>&nbsp;&nbsp; else :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; append(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reverse-list(tail(xs))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List(head(xs)))</code></pre><p>Recall that the default type parameter is <code>?</code> for a type without explicit type parameters. Thus <code>List</code> is equivalent to <code>List&lt;?&gt;</code>. The above definition of <code>reverse-list</code> <span style="font-style:italic;">will</span> allow us to call both lists of integers and strings. Try out the following code again</p><pre><code>println(reverse-list(List(1, 2, 3)))<br>println(reverse-list(List(&quot;Timon&quot;, &quot;and&quot;, &quot;Pumbaa&quot;)))</code></pre><p>and verify that it still prints out</p><pre><code>(3 2 1)<br>(&quot;Pumbaa&quot; &quot;and&quot; &quot;Timon&quot;)</code></pre><p>It seems to work fine now on these cases. What is the problem? </p><p>The problem is in the type of the result of the <code>reverse-list</code> function. <code>reverse-list</code> is annotated to return a <code>List&lt;?&gt;</code>. Thus the following obviously incorrect code will still compile.</p><pre><code>val xs = reverse-list(List(&quot;Timon&quot;, &quot;and&quot;, &quot;Pumbaa&quot;))<br>println(head(xs) + 1)</code></pre> <p>When the compiled program is ran, it crashes with this error.</p><pre><code>FATAL ERROR: Cannot cast value to type.<br>&nbsp;&nbsp; at core/core.stanza:2619.12<br>&nbsp;&nbsp; at test.stanza:15.8</code></pre><p>This is disappointing. The reverse of a list of strings is obviously still a list of strings. So <code>head(xs)</code> should be a <code>String</code>, and Stanza should have stopped us from trying to add an integer to it. More precisely, what we need is the ability for <code>reverse-list</code> to accept lists of any type, but have it also return lists of the <span style="font-style:italic;">same</span> type.</p><p>In place of <code>reverse-list</code>, we&#39;ll instead call the <code>reverse</code> function included in Stanza&#39;s core library, and see that it does not suffer from these problems.</p><pre><code>val xs = reverse(List(&quot;Timon&quot;, &quot;and&quot;, &quot;Pumbaa&quot;))<br>println(head(xs) + 1)</code></pre> <p>Attempting to compile the above gives this error.</p><pre><code>No appropriate function plus for arguments of type (String, Int). <br>Possibilities are:<br>&nbsp;&nbsp; plus: (Byte, Byte) -&gt; Byte at core/core.stanza:2488.21<br>&nbsp;&nbsp; plus: (Int, Int) -&gt; Int at core/core.stanza:2619.12<br>&nbsp;&nbsp; plus: (Long, Long) -&gt; Long at core/core.stanza:2688.21<br>&nbsp;&nbsp; plus: (Float, Float) -&gt; Float at core/core.stanza:2742.21<br>&nbsp;&nbsp; plus: (Double, Double) -&gt; Double at core/core.stanza:2792.21</code></pre><p>which is much more reassuring. We&#39;ll now see how we can write such functions ourselves. </p><h2 id="anchor74">Explicit Type Arguments</h2><p>Here is how to write a <span style="font-style:italic;">polymorphic</span> <code>reverse-list</code> function that takes an explicit type argument.</p><pre><code>defn reverse-list&lt;ElementType&gt; (xs:List&lt;ElementType&gt;) -&gt; List&lt;ElementType&gt; :<br>&nbsp;&nbsp; if empty?(xs) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xs<br>&nbsp;&nbsp; else :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; append(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reverse-list&lt;ElementType&gt;(tail(xs))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List(head(xs)))</code></pre><p><code>reverse-list</code> takes a single type argument called <code>ElementType</code> that represents the type of the elements inside the <code>xs</code> list. Now we need to provide a type argument to <code>reverse-list</code> when we call it.</p><pre><code>reverse-list&lt;Int&gt;(List(1, 2, 3))</code></pre><p>What that does is <span style="font-style:italic;">instantiate</span> a version of <code>reverse-list</code> by replacing <code>ElementType</code> with <code>Int</code> in its type signature. Thus the instantiated function has type</p><pre><code>List&lt;Int&gt; -&gt; List&lt;Int&gt;</code></pre><p>and we then call it with <code>List(1, 2, 3)</code>. </p><p>Let&#39;s use our polymorphic function to reverse lists of integers and strings.</p><pre><code>val xs = reverse-list&lt;Int&gt;(List(1, 2, 3))<br>val ys = reverse-list&lt;String&gt;(List(&quot;Timon&quot;, &quot;and&quot;, &quot;Pumbaa&quot;))<br>println(xs)<br>println(ys)</code></pre><p>Compiling and running the above prints out the same message as before.</p><pre><code>(3 2 1)<br>(&quot;Pumbaa&quot; &quot;and&quot; &quot;Timon&quot;)</code></pre><p>Let&#39;s also verify that the return type of <code>reverse-list</code> is of the proper type.</p><pre><code>val xs = reverse-list&lt;String&gt;(List(&quot;Timon&quot;, &quot;and&quot;, &quot;Pumbaa&quot;))<br>println(head(xs) + 1)</code></pre> <p>Attempting to compile the above gives this error.</p><pre><code>No appropriate function plus for arguments of type (String, Int). <br>Possibilities are:<br>&nbsp;&nbsp; plus: (Byte, Byte) -&gt; Byte at core/core.stanza:2488.21<br>&nbsp;&nbsp; plus: (Int, Int) -&gt; Int at core/core.stanza:2619.12<br>&nbsp;&nbsp; plus: (Long, Long) -&gt; Long at core/core.stanza:2688.21<br>&nbsp;&nbsp; plus: (Float, Float) -&gt; Float at core/core.stanza:2742.21<br>&nbsp;&nbsp; plus: (Double, Double) -&gt; Double at core/core.stanza:2792.21</code></pre><p>So the return type is correct, and Stanza properly catches our mistakes.</p><p>Note that we are responsible for instantiating a correct version of <code>reverse-list</code> to call. If we pass in the wrong type arguments, </p><pre><code>reverse-list&lt;String&gt;(List(1, 2, 3))</code></pre><p>then the program will fail to compile. The above gives this error when we attempt to compile it.</p><pre><code>Cannot call function reverse-list of type List&lt;String&gt; -&gt; List&lt;String&gt; <br>with arguments of type (FullList&lt;Int&gt;).</code></pre><p>As a comment on programming style, the purpose of each type argument in a polymorphic function is typically quite obvious. Thus programmers do not feel the need to give them descriptive names. Here is how <code>reverse-list</code> would commonly be written.</p><pre><code>defn reverse-list&lt;T&gt; (xs:List&lt;T&gt;) -&gt; List&lt;T&gt; :<br>&nbsp;&nbsp; if empty?(xs) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xs<br>&nbsp;&nbsp; else :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; append(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reverse-list&lt;T&gt;(tail(xs))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List(head(xs)))</code></pre><p>The vast majority of type arguments are simply named <code>T</code> (short for <code>Type</code>), or <code>S</code> (because it&#39;s a letter close to <code>T</code>). </p><h2 id="anchor75">Captured Type Arguments</h2><p>Our polymorphic <code>reverse-list</code> function can now reverse lists of any type and also correctly returns a list of the same type. It&#39;s just a little cumbersome to use because we have to pass in the element type of the list we&#39;re reversing each time. This is because <code>T</code> is declared as an <span style="font-style:italic;">explicit</span> type argument. We&#39;ll see now how to have Stanza automatically infer the type argument by declaring it as a <span style="font-style:italic;">captured</span> type argument.</p><p>Here is a polymorphic <code>reverse-list</code> written using a <span style="font-style:italic;">captured</span> type argument.</p><pre><code>defn reverse-list&lt;?T&gt; (xs:List&lt;?T&gt;) -&gt; List&lt;T&gt; :<br>&nbsp;&nbsp; if empty?(xs) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xs<br>&nbsp;&nbsp; else :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; append(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reverse-list(tail(xs))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List(head(xs)))</code></pre><p>A captured type argument is declared with a <code>?</code> prefix, which indicates that it is not passed in explicitly. Instead, it is <span style="font-style:italic;">captured</span> from the types of the arguments it is called with. The type signature above says that <code>reverse-list</code> requires a list to be passed in for <code>xs</code>. Capture <code>T</code> from the element type of <code>xs</code>. </p><p>Now we can call <code>reverse-list</code> without passing in an explicit type argument.</p><pre><code>reverse-list(List(1, 2, 3))</code></pre><p>The argument <code>List(1, 2, 3)</code> has type <code>List&lt;Int&gt;</code>, and thus the type argument <code>T</code> captures the element type <code>Int</code>. </p><p>In the following call,</p><pre><code>reverse-list(List(&quot;Timon&quot;, &quot;and&quot;, &quot;Pumbaa&quot;))</code></pre><p>the argument <code>List(&quot;Timon&quot;, &quot;and&quot;, &quot;Pumbaa&quot;)</code> has a type <code>List&lt;String&gt;</code>, and thus the type argument <code>T</code> captures the element type <code>String</code>. </p><p>Let&#39;s try our example of reversing both integer lists and string lists again.</p><pre><code>val xs = reverse-list(List(1, 2, 3))<br>val ys = reverse-list(List(&quot;Timon&quot;, &quot;and&quot;, &quot;Pumbaa&quot;))<br>println(xs)<br>println(ys)</code></pre><p>Notice that we no longer need to pass in type arguments. Compiling and running the above prints out</p><pre><code>(3 2 1)<br>(&quot;Pumbaa&quot; &quot;and&quot; &quot;Timon&quot;)</code></pre><p>We can also verify that the return type is correct.</p><pre><code>val xs = reverse-list(List(&quot;Timon&quot;, &quot;and&quot;, &quot;Pumbaa&quot;))<br>println(head(xs) + 1)</code></pre><p>Attempting to compile the above gives this error.</p><pre><code>No appropriate function plus for arguments of type (String, Int). <br>Possibilities are:<br>&nbsp;&nbsp; plus: (Byte, Byte) -&gt; Byte at core/core.stanza:2488.21<br>&nbsp;&nbsp; plus: (Int, Int) -&gt; Int at core/core.stanza:2619.12<br>&nbsp;&nbsp; plus: (Long, Long) -&gt; Long at core/core.stanza:2688.21<br>&nbsp;&nbsp; plus: (Float, Float) -&gt; Float at core/core.stanza:2742.21<br>&nbsp;&nbsp; plus: (Double, Double) -&gt; Double at core/core.stanza:2792.21</code></pre><p>Thus the <code>reverse-list</code> function is now polymorphic and it does not require any explicit type arguments. We&#39;ve finished generalizing <code>reverse-list</code> at this point, and it actually now has the same type signature as the <code>reverse</code> function in the core library.</p><h3 id="anchor293">Capture Locations</h3><p>Here&#39;s another example polymorphic function.</p><pre><code>defn store-in-odd-slots&lt;?T&gt; (xs:Array&lt;?T&gt;, v:T) -&gt; False :<br>&nbsp;&nbsp; for i in 1 to length(xs) by 2 do :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xs[i] = v</code></pre><p><code>store-in-odd-slots</code> is a polymorphic function that accepts an array, <code>xs</code>, and an item, <code>v</code>, and stores <code>v</code> at every odd index in <code>xs</code>. Let&#39;s try it out.</p><pre><code>val xs = to-array&lt;String&gt;([&quot;Patrick&quot;, &quot;Sunny&quot;, &quot;Luca&quot;, &quot;Whiskey&quot;, &quot;Emmy&quot;, &quot;Rummy&quot;])<br>store-in-odd-slots(xs, &quot;and&quot;)<br>println(xs)</code></pre><p>prints out</p><pre><code>[&quot;Patrick&quot; &quot;and&quot; &quot;Luca&quot; &quot;and&quot; &quot;Emmy&quot; &quot;and&quot;]</code></pre><p>Let&#39;s now take a closer look at the type signature of <code>store-in-odd-slots</code>.</p><pre><code>defn store-in-odd-slots&lt;?T&gt; (xs:Array&lt;?T&gt;, v:T) -&gt; False</code></pre><p>The <code>?T</code> following the function name</p><pre><code>store-in-odd-slots&lt;?T&gt;</code></pre><p>means that the function is polymorphic and accepts a single captured type argument. The argument list</p><pre><code>(xs:Array&lt;?T&gt;, v:T)</code></pre><p>contains two references to <code>T</code>, but only one of them is prefixed with a <code>?</code>. This means that <code>T</code> is captured <span style="font-style:italic;">only</span> from the element type of <code>xs</code>. </p><p>The capture location for <code>T</code> was chosen carefully. Consider the following type definitions.</p><pre><code>deftype Shape<br>deftype Circle &lt;: Shape</code></pre><p>where all circles are also shapes, but not all shapes are circles. </p><p>The following usage of <code>store-in-odd-slots</code></p><pre><code>val shapes = Array&lt;Shape&gt;(10)<br>store-in-odd-slots(shapes, new Circle)</code></pre><p>compiles correctly. <code>T</code> is captured from the element type of <code>Array&lt;Shape&gt;</code>, and is thus <code>Shape</code>. The instantiated <code>store-in-odd-slots</code> therefore has type</p><pre><code>(Array&lt;Shape&gt;, Shape) -&gt; False</code></pre><p>and can be suitably called with <code>shapes</code> and <code>new Circle</code>.</p><p>But this next usage</p><pre><code>val circles = Array&lt;Circle&gt;(10)<br>store-in-odd-slots(circles, new Shape)</code></pre><p>fails with this error</p><pre><code>Cannot call function store-in-odd-slots of type (Array&lt;Circle&gt;, Circle) -&gt; False<br>with arguments of type (Array&lt;Circle&gt;, Shape).</code></pre><p>This is consistent with our intuition. You cannot store an arbitrary shape into an array that can only hold circles. As an exercise, think about what would happen if <code>store-in-odd-slots</code> was instead declared the following way.</p><pre><code>defn store-in-odd-slots&lt;?T&gt; (xs:Array&lt;T&gt;, v:?T) -&gt; False</code></pre><p>As a general rule of thumb, the majority of polymorphic functions operate on a collection of some sort. The type argument is <span style="font-style:italic;">almost always</span> captured from the element type of the collection. </p><h3 id="anchor294">Multiple Capture Locations</h3><p>After reading the previous section, you might be naturally wondering what happens when there are <span style="font-style:italic;">multiple</span> capture locations. If there are multiple capture locations, then the final captured type is the <span style="font-style:italic;">union</span> of all the types captured from each location.</p><p>Here is an example of a function that makes use of two capture locations.</p><pre><code>defn append-lists&lt;?T&gt; (xs:List&lt;?T&gt;, ys:List&lt;?T&gt;) -&gt; List&lt;T&gt; :<br>&nbsp;&nbsp; if empty?(xs) : ys<br>&nbsp;&nbsp; else : cons(head(xs), append-lists(tail(xs), ys))</code></pre><p>The type argument <code>T</code> is captured from both the element type of <code>xs</code> <span style="font-style:italic;">and</span> the element of type <code>ys</code>. Thus if we call <code>append-lists</code> on a list of integers and a list of strings,</p><pre><code>val xs = List(1, 2, 3)<br>val ys = List(&quot;Timon&quot;, &quot;and&quot;, &quot;Pumbaa&quot;)<br>val zs = append-lists(xs, ys)</code></pre><p>then the resulting type of <code>zs</code> is <code>List&lt;Int|String&gt;</code>. </p><h3 id="anchor295">Example: map-list</h3><p>Let&#39;s try writing our own polymorphic <code>map</code> function on lists. We&#39;ll call ours <code>map-list</code>. <code>map-list</code> accepts a function, <code>f</code>, and a list, <code>xs</code>, and returns a new list containing the results of calling <code>f</code> on each item in <code>xs</code>. To start off, here&#39;s the function definition without any type annotations.</p><pre><code>defn map-list (f, xs) :<br>&nbsp;&nbsp; if empty?(xs) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List()<br>&nbsp;&nbsp; else :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val y = f(head(xs))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val ys = map-list(f, tail(xs))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cons(y, ys)</code></pre><p>Let&#39;s verify that it works as intended.</p><pre><code>val xs = to-list([&quot;Timon&quot;, &quot;and&quot;, &quot;Pumbaa&quot; &quot;are&quot;, &quot;good&quot;, &quot;friends&quot;])<br>val lengths = map-list(length, xs)<br>println(lengths)</code></pre><p>Compiling and running the above prints out</p><pre><code>(5 3 6 3 4 7)</code></pre><p>Let&#39;s start off with figuring out the type of <code>xs</code>, because it seems easier. It&#39;s a list for sure, and <code>map-list</code> should be able to work on lists of any type. So <code>xs</code> is therefore of type</p><pre><code>xs:List&lt;?T&gt;</code></pre><p>and <code>T</code> is a captured type argument for <code>map-list</code>. </p><p>Next, let&#39;s figure out the type of <code>f</code>. It&#39;s a function for sure, and it&#39;s called with only a single argument. So it&#39;s at least</p><pre><code>f:? -&gt; ?</code></pre><p>Next we know that <code>f</code> is called with items from <code>xs</code>, which is a list of <code>T</code>&#39;s, so <code>f</code> has to accept <code>T</code>&#39;s. Now we know it&#39;s at least</p><pre><code>f:T -&gt; ?</code></pre><p>Finally, what is <code>f</code> allowed to return? Well, <code>f</code> is allowed to return anything actually. So let&#39;s introduce another captured type argument. The final type of <code>f</code> is</p><pre><code>f:T -&gt; ?S</code></pre><p>Now that we know the types of its arguments, the last step is to figure out what <code>map-list</code> returns. We know that it returns a list, and we also know that the list contains the results of calling <code>f</code>. Since we now know that <code>f</code> returns <code>S</code>&#39;s, therefore <code>map-list</code> returns a list of <code>S</code>&#39;s. Here is the complete type signature for <code>map-list</code>.</p><pre><code>defn map-list&lt;?T,?S&gt; (f:T -&gt; ?S, xs:List&lt;?T&gt;) -&gt; List&lt;S&gt;</code></pre><p>Let&#39;s try our test code again with our typed <code>map-list</code> function and ensure it works as expected.</p><pre><code>val xs = to-list([&quot;Timon&quot;, &quot;and&quot;, &quot;Pumbaa&quot; &quot;are&quot;, &quot;good&quot;, &quot;friends&quot;])<br>val lengths = map-list(length, xs)<br>println(lengths)</code></pre><p>Running the above prints out</p><pre><code>(5 3 6 3 4 7)</code></pre><p>as before. </p><p>To double check the inferred return type of <code>map-list</code>, let&#39;s cast <code>lengths</code> to an obviously incorrect type, and read what Stanza says about its type. </p><pre><code>lengths as False</code></pre><p>Compiling the above gives us the error</p><pre><code>Cannot cast expression of type List&lt;Int&gt; to type False.</code></pre><p>So Stanza says that <code>lengths</code> is a list of integers, which is correct. </p><h3 id="anchor296">Example: map-both</h3><p>Here&#39;s some more practice on using captured type arguments. Here is the un-annotated definition for the <code>map-both</code> function.</p><pre><code>defn map-both (f, g, xs) :<br>&nbsp;&nbsp; for x in xs map :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [f(x), g(x)]</code></pre><p><code>map-both</code> accepts two functions, <code>f</code> and <code>g</code>, and a list, <code>xs</code>, and returns a list containing two-element tuples. The first elements in all the tuples are the results of calling <code>f</code> on each item in <code>xs</code>, and the second elements in all the tuples are the results of calling <code>g</code> on each item in <code>xs</code>.</p><p>Similar to before, the list, <code>xs</code>, is the easiest argument to figure out the type signature for.</p><pre><code>xs:List&lt;?T&gt;</code></pre><p><code>f</code> needs to be a function that can be called with items from <code>xs</code>, and can return anything.</p><pre><code>f:T -&gt; ?S</code></pre><p><code>g</code> also needs to be a function that can called with items from <code>xs</code>, and can also return anything. </p><pre><code>g:T -&gt; ?R</code></pre><p><code>map-both</code> returns a list of tuples. The first elements in the tuples are results of calling <code>f</code>, and the second elements are results of calling <code>g</code>.</p><pre><code>List&lt;[S, R]&gt;</code></pre><p>Thus the complete definition for <code>map-both</code> is</p><pre><code>defn map-both&lt;?T,?S,?R&gt; (f:T -&gt; ?S, g:T -&gt; ?R, xs:List&lt;?T&gt;) -&gt; List&lt;[S, R]&gt; :<br>&nbsp;&nbsp; for x in xs map :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [f(x), g(x)]</code></pre><p>Let&#39;s try it out on a list of strings.</p><pre><code>val xs = to-list([&quot;Timon&quot;, &quot;and&quot;, &quot;Pumbaa&quot;, &quot;are&quot;, &quot;good&quot;, &quot;friends&quot;])<br>val zs = map-both(<br>&nbsp;&nbsp; xs,<br>&nbsp;&nbsp; fn (x) : x[2]<br>&nbsp;&nbsp; fn (y) : length(y) * 2)<br>println(zs)</code></pre><p>which prints out</p><pre><code>([&#39;m&#39; 10] [&#39;d&#39; 6] [&#39;m&#39; 12] [&#39;e&#39; 6] [&#39;o&#39; 8] [&#39;i&#39; 14])</code></pre><p>Let&#39;s cast <code>zs</code> to something silly to see what Stanza says about its type. Attempting to compile the following</p><pre><code>zs as False</code></pre><p>gives us this error.</p><pre><code>Cannot cast expression of type List&lt;[Char, Int]&gt; to type False.</code></pre><p>So <code>zs</code> has type <code>List&lt;[Char, Int]&gt;</code>, which is what we expect.</p><h2 id="anchor76">Parametric Types</h2><p>You have been shown how to define your own types using <code>deftype</code> and also the shorthand <code>defstruct</code>. But none of the types you&#39;ve defined thus far accept <span style="font-style:italic;">type parameters</span>. This stood out the most in our definition of the <code>Stack</code> type which was only able to store <span style="font-style:italic;">String</span> objects. We&#39;ll now learn how to declare our own <span style="font-style:italic;">parametric types</span>.</p><h3 id="anchor297">Declaring a Parametric Type</h3><p>Here is an example of a simple type that takes two type parameters. </p><pre><code>deftype Either&lt;L,R&gt;</code></pre><p><code>Either</code> contains two wrapped objects, a left object of type <code>L</code>, and a right object of type <code>R</code>. </p><p>This is all there is to defining a parametric type! The rest of this section covers mechanisms that have already been introduced, but we&#39;ll go through them in the context of the <code>Either</code> type for practice.</p><h3 id="anchor298">Declaring Multis</h3><p>Let&#39;s define the fundamental operations for an <code>Either</code> object, which are simply getter functions for retrieving the two wrapped objects.</p><pre><code>defmulti left&lt;?L&gt; (e:Either&lt;?L,?&gt;) -&gt; L<br>defmulti right&lt;?R&gt; (e:Either&lt;?,?R&gt;) -&gt; R</code></pre><p>Notice that the <code>left</code> and <code>right</code> functions each take only a single type argument. The other type parameter for the <code>Either</code> object is left as <code>?</code> to indicate that it is free to be anything.</p><h3 id="anchor299">Creating Either Objects</h3><p>Now let&#39;s write a constructor function for creating <code>Either</code> objects. We&#39;ll start with a function that can only create <code>Either&lt;Int,String&gt;</code> objects.</p><pre><code>defn Either (l:Int, r:String) :<br>&nbsp;&nbsp; new Either&lt;Int,String&gt; :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod left (this) : l<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod right (this) : r</code></pre><p>Let&#39;s try it out.</p><pre><code>val e = Either(42, &quot;Timon&quot;)<br>println(&quot;The left object is %_.&quot; % [left(e)])<br>println(&quot;The right object is %_.&quot; % [right(e)])</code></pre><p>prints out</p><pre><code>The left object is 42.<br>The right object is Timon.</code></pre><h3 id="anchor300">Polymorphic Constructor Function</h3><p>Now that we can successfully create specific <code>Either</code> objects, let&#39;s generalize our constructor function by making it polymorphic using type arguments. The following declares <code>Either</code> as taking two explicit type arguments, one for each wrapped object.</p><pre><code>defn Either&lt;L,R&gt; (l:L, r:R) :<br>&nbsp;&nbsp; new Either&lt;L,R&gt; :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod left (this) : l<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod right (this) : r</code></pre><p>Now <code>Either</code> objects are created in the following way.</p><pre><code>val e = Either&lt;Int,String&gt;(42, &quot;Timon&quot;)</code></pre><p>The way in which <code>Either</code> objects are created now resembles how we&#39;ve been creating many of the other types included in the core library, such as arrays and vectors. This is not a coincidence. The construction function for arrays and vectors are also just regular functions that take explicit type arguments and return instances of parametric types.</p><h3 id="anchor301">Parametric Structs</h3><p>The <code>defstruct</code> expression also accepts type parameters for creating parametric structs. As mentioned previously, the <code>defstruct</code> expression is simply a syntactic shorthand for declaring a new type, getter functions for its fields, and a default construction function. Thus all the code we&#39;ve written previously to define the <code>Either</code> type can be neatly expressed as</p><pre><code>defstruct Either&lt;L,R&gt; :<br>&nbsp;&nbsp; left: L<br>&nbsp;&nbsp; right: R</code></pre><h3 id="anchor302">Constructor Function with Captured Arguments</h3><p>Specifically for creating <code>Either</code> objects, it is also not necessary to have the user explicitly specify the types of the left and right objects. Let&#39;s make the constructor function more convenient to call by using captured type arguments.</p><pre><code>defn Either&lt;?L,?R&gt; (l:?L, r:?R) :<br>&nbsp;&nbsp; new Either&lt;L,R&gt; :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod left (this) : l<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod right (this) : r</code></pre><p>Now we can create an <code>Either</code> object like this</p><pre><code>val e = Either(42, &quot;Timon&quot;)</code></pre><p>and have Stanza automatically infer that <code>e</code> is an <code>Either&lt;Int,String&gt;</code> based on the types of <code>42</code> and <code>&quot;Timon&quot;</code>.</p><h3 id="anchor303">When <span style="font-style:italic;">not</span> to Use Captured Arguments</h3><p>We showed above how to write a constructor function using captured arguments that did not require the left and right object types to be passed in explicitly to <code>Either</code>. This makes the constructor function for <code>Either</code> objects very similar to the constructor function for <code>List</code> objects, which also does not require any explicit type arguments. This is <span style="font-style:italic;">not</span> always an appropriate thing to do.</p><p>Let us suppose that <code>Either</code> is a <span style="font-style:italic;">mutable</span> datastructure; that we can change the left and right objects after the object has been created. The type definition for <code>Either</code> would stay the same, but it would gain two more fundamental operations.</p><pre><code>defmulti left&lt;?L&gt; (e:Either&lt;?L,?&gt;) -&gt; L<br>defmulti right&lt;?R&gt; (e:Either&lt;?,?R&gt;) -&gt; R<br>defmulti set-left&lt;?L&gt; (e:Either&lt;?L,?&gt;, v:L) -&gt; False<br>defmulti set-right&lt;?R&gt; (e:Either&lt;?,?R&gt;, v:R) -&gt; False</code></pre><p>Notice, especially, the capture locations of the type arguments in the setter functions. </p><p>The constructor function would be changed to now accept not the left and right objects, but the <span style="font-style:italic;">initial</span> left and right objects, since they may change later on.</p><pre><code>defn Either&lt;?L,?R&gt; (l0:?L, r0:?R) :<br>&nbsp;&nbsp; var l = l0<br>&nbsp;&nbsp; var r = r0<br>&nbsp;&nbsp; new Either&lt;L,R&gt; :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod left (this) : l<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod right (this) : r<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod set-left (this, v:L) : l = v<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod set-right (this, v:R) : r = v</code></pre><p>For the next part, let us again assume that we have definitions for some basic shapes.</p><pre><code>deftype Shape<br>deftype Circle &lt;: Shape<br>deftype Rectangle &lt;: Shape<br><br>defmethod print (o:OutputStream, c:Circle) : print(o, &quot;Circle&quot;)<br>defmethod print (o:OutputStream, r:Rectangle) : print(o, &quot;Rectangle&quot;)</code></pre><p>Let&#39;s try creating a mutable <code>Either</code> object now.</p><pre><code>defn my-favorite-shape () -&gt; Shape :<br>&nbsp;&nbsp; new Circle<br><br>val e = Either(42, my-favorite-shape())<br>println(&quot;After creation:&quot;)<br>println(&quot;The left object is %_&quot; % [left(e)])<br>println(&quot;The right object is %_&quot; % [right(e)])<br><br>set-left(e, 256)<br>set-right(e, new Rectangle)<br>println(&quot;\nAfter mutation:&quot;)<br>println(&quot;The left object is %_&quot; % [left(e)])<br>println(&quot;The right object is %_&quot; % [right(e)])</code></pre><p>Compiling and running the above prints out</p><pre><code>After creation:<br>The left object is 42<br>The right object is Circle<br><br>After mutation:<br>The left object is 256<br>The right object is Rectangle</code></pre><p>Everything seems to be working, but pay attention to what happens next. </p><p>The type signature for <code>my-favorite-shape</code> is not as precise as it could be. It&#39;s annotated to return <code>Shape</code>, but it&#39;s more precise to say that it returns <code>Circle</code>. So let&#39;s improve <code>my-favorite-shape</code>&#39;s type signature.</p><pre><code>defn my-favorite-shape () -&gt; Circle :<br>&nbsp;&nbsp; new Circle</code></pre><p>Now try compiling and running the program again. It will now give this error.</p><pre><code>Cannot call function set-right of type (Either&lt;?, Circle&gt;, Circle) -&gt; False <br>with arguments of type (Either&lt;Int, Circle&gt;, Rectangle).</code></pre><p>What is going on? Why would changing (actually improving) the type signature for <code>my-favorite-shape</code> affect the later call to <code>set-right</code>? </p><p>The problem, as is evident in the error message, is that the inferred type for <code>e</code> is <code>Either&lt;Int, Circle&gt;</code>. This is not right. Even though the <span style="font-style:italic;">initial</span> right object was a <code>Circle</code>, that doesn&#39;t mean we want <code>e</code> to <span style="font-style:italic;">only ever</span> hold <code>Circle</code> objects as its right object.</p><p>This is one of those cases where using a captured type argument is inappropriate. For a mutable <code>Either</code> object, the types of the left and right objects should be passed in explicitly.</p><p>Here is the constructor function rewritten to use explicit type arguments.</p><pre><code>defn Either&lt;L,R&gt; (l0:L, r0:R) :<br>&nbsp;&nbsp; var l = l0<br>&nbsp;&nbsp; var r = r0<br>&nbsp;&nbsp; new Either&lt;L,R&gt; :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod left (this) : l<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod right (this) : r<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod set-left (this, v:L) : l = v<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod set-right (this, v:R) : r = v</code></pre><p>And here is our original test code rewritten to pass in explicit type arguments.</p><pre><code>defn my-favorite-shape () -&gt; Shape :<br>&nbsp;&nbsp; new Circle<br><br>val e = Either&lt;Int, Shape&gt;(42, my-favorite-shape())<br>println(&quot;After creation:&quot;)<br>println(&quot;The left object is %_&quot; % [left(e)])<br>println(&quot;The right object is %_&quot; % [right(e)])<br><br>set-left(e, 256)<br>set-right(e, new Rectangle)<br>println(&quot;\nAfter mutation:&quot;)<br>println(&quot;The left object is %_&quot; % [left(e)])<br>println(&quot;The right object is %_&quot; % [right(e)])</code></pre><p>Verify that it still compiles and runs correctly. </p><p>At this point, we can try making the same change to <code>my-favorite-shape</code>&#39;s type signature.</p><pre><code>defn my-favorite-shape () -&gt; Circle :<br>&nbsp;&nbsp; new Circle</code></pre><p>This time, however, the program still compiles and continues to run as before. </p><p>Here are the basic rules of thumb for choosing between using explicit or captured type arguments. If you&#39;re creating an immutable object then feel free to use captured type arguments. If you&#39;re creating a mutable object, then use explicit type arguments. </p><p>These issues surrounding captured type arguments and mutable objects is also why <code>to-array</code> and <code>to-vector</code> require explicit type arguments and why <code>to-list</code> does not.</p><h2 id="anchor77">Match Expressions and Type Erasure</h2><p>One subtlety concerning Stanza&#39;s parametric type system is a concept called <span style="font-style:italic;">type erasure</span>. It roughly means that, given a program, if we replace every type argument with the <code>?</code> type, it should still run and compute the same result (providing that the original program doesn&#39;t fail). Said another way, the setting of a type argument can never change what is computed by a program.</p><p>Here is an example of incorrectly attempting to use a type argument to affect which branch is taken in a match expression.</p><pre><code>defn check-if&lt;T&gt; (x) :<br>&nbsp;&nbsp; match(x) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (x:T) : true<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (x) : false</code></pre><p>Let&#39;s try it out on a <code>String</code> object.</p><pre><code>println(check-if&lt;Int&gt;(&quot;Timon&quot;))</code></pre><p>Compiling and running the above prints out</p><pre><code>FATAL ERROR: Cannot cast value to type.<br>&nbsp;&nbsp; at test.stanza:15.8<br>&nbsp;&nbsp; at test.stanza:18.8</code></pre><p>Here is what is happening underneath. The <span style="font-style:italic;">dispatch</span> type in a match branch has all of its type arguments and parametric types erased. Thus the code above is equivalent to the following</p><pre><code>defn check-if&lt;T&gt; (x) :<br>&nbsp;&nbsp; match(x) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (y:?) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val x = y as T<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (y:?) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; false</code></pre><p>and the error message arises because <code>y</code> cannot be cast to a <code>T</code> object. We intentionally designed Stanza so that there is no possible way to write a function such as <code>check-if</code>.</p><h2 id="anchor78">Revisiting Stack</h2><p>At this point, we have all the requisite knowledge for writing a parametric version of our <code>Stack</code> class from chapter 6. Here are our old definitions for the <code>Stack</code> type and its fundamental operations.</p><pre><code>deftype Stack &lt;: Collection&lt;String&gt;<br>defmulti push (s:Stack, x:String) -&gt; False<br>defmulti pop (s:Stack) -&gt; String<br>defmulti empty? (s:Stack) -&gt; True|False</code></pre><p>A <code>Stack</code> is declared to be a collection of strings, and its fundamental operations allow us to push and pop strings from it.</p><p>Here is the original constructor function.</p><pre><code>defn Stack (capacity:Int) -&gt; Stack :<br>&nbsp;&nbsp; val items = Array&lt;String&gt;(capacity)<br>&nbsp;&nbsp; var size = 0<br>&nbsp;&nbsp; new Stack :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod push (this, x:String) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if size == capacity : fatal(&quot;Stack is full!&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; items[size] = x<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size = size + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod pop (this) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if size == 0 : fatal(&quot;Stack is empty!&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size = size - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; items[size]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod empty? (this) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size == 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod print (o:OutputStream, this) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(o, &quot;Stack containing [&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print-all(o, join(this, &quot; &quot;))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(o, &quot;]&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod to-seq (this) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; take-n(size, items)</code></pre><h3 id="anchor304">Parametric Type Declaration</h3><p>The first step is to declare <code>Stack</code> as a parametric type. </p><pre><code>deftype Stack&lt;T&gt; &lt;: Collection&lt;T&gt;</code></pre><p>Thus, <code>Stack</code> now takes a type parameter, <code>T</code>, that indicates what types of objects the stack may hold, and is also no longer a collection of strings. It is now a collection of <code>T</code>&#39;s. </p><h3 id="anchor305">Polymorphic Fundamental Operations</h3><p>The second step is to declare its fundamental operations as polymorphic functions.</p><pre><code>defmulti push&lt;?T&gt; (s:Stack&lt;?T&gt;, x:T) -&gt; False<br>defmulti pop&lt;?T&gt; (s:Stack&lt;?T&gt;) -&gt; T<br>defmulti empty? (s:Stack) -&gt; True|False</code></pre><p>both <code>push</code> and <code>pop</code> now accept a captured type argument, <code>T</code>, that indicates the element type of the stack object. Here are some points to take note of. Notice that the <code>x</code> argument for <code>push</code> is not a capture location for <code>T</code>. This is consistent with our earlier discussion in the section on capture locations. Also notice that the <code>empty?</code> multi is unchanged, as the types of the objects in a stack are not needed to check whether the stack is empty.</p><h3 id="anchor306">Polymorphic Constructor Function</h3><p>The last step is to make its constructor function polymorphic.</p><pre><code>defn Stack&lt;T&gt; (capacity:Int) -&gt; Stack&lt;T&gt; :<br>&nbsp;&nbsp; val items = Array&lt;T&gt;(capacity)<br>&nbsp;&nbsp; var size = 0<br>&nbsp;&nbsp; new Stack :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod push (this, x:T) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if size == capacity : fatal(&quot;Stack is full!&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; items[size] = x<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size = size + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod pop (this) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if size == 0 : fatal(&quot;Stack is empty!&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size = size - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; items[size]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod empty? (this) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size == 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod print (o:OutputStream, this) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(o, &quot;Stack containing [&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print-all(o, join(this, &quot; &quot;))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(o, &quot;]&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod to-seq (this) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; take-n(size, items)</code></pre><p>The constructor function now takes an explicit type argument, <code>T</code>, indicating the element type of the stack object, and returns a <code>Stack&lt;T&gt;</code>. Notice that the backing array, <code>items</code>, is no longer an <code>Array&lt;String&gt;</code>. It is now declared as an <code>Array&lt;T&gt;</code> in order to hold the items in the stack. <code>push</code> now also accepts a <code>T</code> value instead of a <code>String</code> value. The rest of the function is unchanged. </p><h3 id="anchor307">Trying It Out</h3><p>Let&#39;s try out our parametric <code>Stack</code> type using a variation of our original test code.</p><pre><code>defn main () :<br>&nbsp;&nbsp; val s = Stack&lt;Int&gt;(10)<br>&nbsp;&nbsp; for x in [1, 5, 2, 42, -11, 2, 5, 10, -42] do :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push(s, x)<br><br>&nbsp;&nbsp; println(&quot;1. Contents of s&quot;)<br>&nbsp;&nbsp; println(s)<br><br>&nbsp;&nbsp; println(&quot;\n2. Index of 42&quot;)<br>&nbsp;&nbsp; println(index-of(s, 42))<br><br>&nbsp;&nbsp; println(&quot;\n3. Does it contain any negative numbers?&quot;)<br>&nbsp;&nbsp; println(any?({_ &lt; 0}, s))<br><br>&nbsp;&nbsp; println(&quot;\n4. Are all numbers negative?&quot;)<br>&nbsp;&nbsp; println(all?({_ &lt; 0}, s))<br><br>&nbsp;&nbsp; println(&quot;\n5. What are the negative numbers?&quot;)<br>&nbsp;&nbsp; val cap-s = filter({_ &lt; 0}, s)<br>&nbsp;&nbsp; println-all(join(cap-s, &quot;, &quot;))<br><br>&nbsp;&nbsp; println(&quot;\n6. What are its unique elements?&quot;)<br>&nbsp;&nbsp; println(unique(s))<br><br>main()</code></pre><p>Compiling and running the above prints out</p><pre><code>1. Contents of s<br>Stack containing [1 5 2 42 -11 2 5 10 -42]<br><br>2. Index of 42<br>3<br><br>3. Does it contain any negative numbers?<br>true<br><br>4. Are all numbers negative?<br>false<br><br>5. What are the negative numbers?<br>-11, -42<br><br>6. What are its unique elements?<br>(1 5 2 42 -11 10 -42)</code></pre><p>Our parametric stack type is now quite general. It can hold items of different types, and it supports all the operations in the core sequence library. Actually, the <code>Array</code> and <code>Vector</code> types in the core library are defined in much the same way as <code>Stack</code>.</p>
        </td>
        <td class="rest">
          <img url="resources/spacer.gif"></img>
        </td>
      </tr>
      <tr><td colspan="3" class="footer">
        Site design by Luca Li. Copyright 2015.
      </td></tr>
    </table>
  </body>
</html>
