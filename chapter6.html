
<!DOCTYPE html>
<html>
  <head>
    <title>L.B.Stanza</title>
    <link type="text/css" rel="stylesheet" href="resources/mainstyle.css">
    <link type="text/css" rel="stylesheet" href="resources/documentation.css">
  </head>
  <body>
    <table class="wrap">
      <tr><td colspan="3" class="banner">
        <a href="index.html">Home</a><a href="stanzabyexample.html">Table of Contents</a><a href="chapter5.html">Previous Chapter</a><a href="chapter7.html">Next Chapter</a>
      </td></tr>
      <tr>
        <td class="nav">
          <h1>NAVIGATION</h1>
          <h2><a href="#anchor249">Programming with Sequences</a></h2><h3><a href="#anchor62">Fundamental Operations</a></h3><h3><a href="#anchor63">Writing a Sequence Function</a></h3><h4><a href="#anchor250">Seqable</a></h4><h3><a href="#anchor64">Lazy Sequences</a></h3><h4><a href="#anchor251">seq</a></h4><h3><a href="#anchor65">Using The Sequence Library</a></h3><h4><a href="#anchor252">Sequence Creators</a></h4><h4><a href="#anchor253">to-seq</a></h4><h4><a href="#anchor254">repeatedly</a></h4><h4><a href="#anchor255">repeat-while</a></h4><h4><a href="#anchor256">Sequence Operators</a></h4><h4><a href="#anchor257">cat</a></h4><h4><a href="#anchor258">join</a></h4><h4><a href="#anchor259">take-n</a></h4><h4><a href="#anchor260">filter</a></h4><h4><a href="#anchor261">seq</a></h4><h4><a href="#anchor262">Sequence Reducers</a></h4><h4><a href="#anchor263">contains?</a></h4><h4><a href="#anchor264">index-of</a></h4><h4><a href="#anchor265">unique</a></h4><h4><a href="#anchor266">to-array</a></h4><h4><a href="#anchor267">to-vector</a></h4><h4><a href="#anchor268">to-list</a></h4><h4><a href="#anchor269">reduce</a></h4><h3><a href="#anchor66">Collection versus Seqable</a></h3><h3><a href="#anchor67">Revisiting Stack</a></h3>
        </td>
        <td class="main">
          <h1 id="anchor249">Programming with Sequences</h1><p>A sequence is a series of objects. At any point, you may ask whether a sequence is empty, and if it is not empty you may retrieve the next object. Many datastructures can represent their items as a sequence. For example, a sequence for representing the items in an array could begin with the item at index <code>0</code>. Subsequent items in the sequence would correspond to subsequent items in the array. When it reaches the end of the array then the sequence is empty.</p><p>While sequences are not a core language feature, they do play a fundamental part in the design of Stanza&#39;s core library. In this chapter we&#39;ll see how to fully exploit their power, and by doing so, avoid having to repeatedly reimplement many common programming patterns ourselves. </p><h2 id="anchor62">Fundamental Operations</h2><p>A sequence is represented by the <code>Seq</code> type in Stanza. Let&#39;s first create a sequence containing all the strings in a tuple.</p><pre><code>val xs = to-seq([&quot;Timon&quot; &quot;and&quot; &quot;Pumbaa&quot; &quot;are&quot; &quot;good&quot; &quot;friends.&quot;])</code></pre><p>This creates the sequence <code>xs</code>, which has type <code>Seq&lt;String&gt;</code> indicating that it is a sequence of strings.</p><p>Fundamentally, a sequence is defined by three operations.</p><ol><li>You may ask whether a sequence is empty.
</li><li>You may take a peek at the next item in the sequence.
</li><li>You may take out the next item in the sequence.
</li></ol><p>Here is how to ask whether our <code>xs</code> sequence is empty.</p><pre><code>if empty?(xs) :<br>&nbsp;&nbsp; println(&quot;xs is empty.&quot;)<br>else :<br>&nbsp;&nbsp; println(&quot;xs is not empty.&quot;)</code></pre><p>which prints out</p><pre><code>xs is not empty.</code></pre><p>because we haven&#39;t taken anything out of the sequence yet. </p><p>If the sequence is not empty, then you can take a peek at the next item in the sequence like this.</p><pre><code>val x0 = peek(xs)<br>println(&quot;The next item is %_.&quot; % [x0])</code></pre><p>which prints out</p><pre><code>The next item is Timon.</code></pre><p>Peeking at an empty sequence is a fatal error.</p><p>Peeking at a sequence does not change the state of a sequence. If you peek again at the same sequence, it returns the same thing.</p><pre><code>val x1 = peek(xs)<br>println(&quot;The next item is still %_.&quot; % [x1])</code></pre><p>which prints out</p><pre><code>The next item is still Timon.</code></pre><p>Once you&#39;ve determined that the sequence is not empty, you may take out the next item in the sequence.</p><pre><code>val y0 = next(xs)<br>println(&quot;Took out item %_ from xs.&quot; % [y0])</code></pre><p>which prints out</p><pre><code>Took out item Timon from xs.</code></pre><p>Calling <code>next</code> on a sequence <span style="font-style:italic;">does</span> change the state of a sequence. If you call <code>next</code> again on the same sequence, it will return the following item in the sequence.</p><pre><code>val y1 = next(xs)<br>println(&quot;Now took out item %_ from xs.&quot; % [y1])</code></pre><p>which prints out</p><pre><code>Now took out item and from xs.</code></pre><p>Here is the standard pattern for printing out all the items in a sequence. </p><pre><code>while not empty?(xs) :<br>&nbsp;&nbsp; println(&quot;Next item is %_&quot; % [next(xs)])</code></pre><p>which prints out</p><pre><code>Next item is Timon<br>Next item is and<br>Next item is Pumbaa<br>Next item is are<br>Next item is good<br>Next item is friends.</code></pre><h2 id="anchor63">Writing a Sequence Function</h2><p>Let&#39;s now write a function that takes a sequence argument. <code>cum-sum</code> takes a sequence of integers, <code>xs</code>, and returns a vector containing the cumulative sum of all the numbers in <code>xs</code>.</p><pre><code>defn cum-sum (xs:Seq&lt;Int&gt;) :<br>&nbsp;&nbsp; val ys = Vector&lt;Int&gt;()<br>&nbsp;&nbsp; var accum = 0<br>&nbsp;&nbsp; while not empty?(xs) :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; accum = accum + next(xs)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add(ys, accum)<br>&nbsp;&nbsp; ys</code></pre><p>Let&#39;s try it out on some numbers.</p><pre><code>defn main () :<br>&nbsp;&nbsp; val xs = [1, 1, 3, 1, 5, 6, 2, 3, 8]<br>&nbsp;&nbsp; println(cum-sum(to-seq(xs)))<br><br>main()</code></pre><p>Compiling and running the above prints out</p><pre><code>[1 2 5 6 11 17 19 22 30]</code></pre><h3 id="anchor250">Seqable</h3><p>Notice that in the call to <code>cum-sum</code> we have to explicitly convert our tuple into a <code>Seq</code> object using <code>to-seq</code>. Otherwise Stanza would issue a type error. For convenience, however, it would be better to move the call to <code>to-seq</code> inside the body of <code>cum-sum</code> and have <code>cum-sum</code> accept <span style="font-style:italic;">any</span> object that supports <code>to-seq</code>. </p><p>This brings us to the type <code>Seqable</code>. Values of type <code>Seqable</code> support only a single operation: calling <code>to-seq</code> on a <code>Seqable</code> object returns a <code>Seq</code>. <code>Seqable</code> also accepts a <span style="font-style:italic;">type parameter</span> that indicates the type of element it contains. Thus calling <code>to-seq</code> on a <code>Seqable&lt;Int&gt;</code> returns a <code>Seq&lt;Int&gt;</code>.</p><p>Let&#39;s change our <code>cum-sum</code> function to accept an object of type <code>Seqable&lt;Int&gt;</code>.</p><pre><code>defn cum-sum (xs:Seqable&lt;Int&gt;) :<br>&nbsp;&nbsp; val xs-seq = to-seq(xs)<br>&nbsp;&nbsp; val ys = Vector&lt;Int&gt;()<br>&nbsp;&nbsp; var accum = 0<br>&nbsp;&nbsp; while not empty?(xs-seq) :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; accum = accum + next(xs-seq)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add(ys, accum)<br>&nbsp;&nbsp; ys</code></pre><p>Now our <code>cum-sum</code> function is general enough to be called with any <code>Seqable</code> object. This includes ranges, tuples, arrays, vectors, lists (which we will cover later), and even other sequences. Let&#39;s try it out.</p><pre><code>defn main () :<br>&nbsp;&nbsp; val xs = [1, 1, 3, 1, 5, 6, 2, 3, 8]<br>&nbsp;&nbsp; val ys = to-array&lt;Int&gt;([1, 1, 3, 1, 5, 6, 2, 3, 8])<br>&nbsp;&nbsp; val zs = to-vector&lt;Int&gt;([1, 1, 3, 1, 5, 6, 2, 3, 8])<br>&nbsp;&nbsp; val ws = to-list([1, 1, 3, 1, 5, 6, 2, 3, 8])<br><br>&nbsp;&nbsp; println(cum-sum(xs))<br>&nbsp;&nbsp; println(cum-sum(ys))<br>&nbsp;&nbsp; println(cum-sum(zs))<br>&nbsp;&nbsp; println(cum-sum(ws))<br><br>main()</code></pre><p>which prints out</p><pre><code>[1 2 5 6 11 17 19 22 30]<br>[1 2 5 6 11 17 19 22 30]<br>[1 2 5 6 11 17 19 22 30]<br>[1 2 5 6 11 17 19 22 30]</code></pre><p>This is the mechanism that allows the core library functions (such as <code>do</code>) to operate on all sorts of collections. <code>do</code> just accepts a <code>Seqable</code> argument. </p><p>And since <code>do</code> accepts a <code>Seqable</code> argument, we can actually rewrite our <code>cum-sum</code> function more elegantly using <code>do</code>. </p><pre><code>defn cum-sum (xs:Seqable&lt;Int&gt;) :<br>&nbsp;&nbsp; val ys = Vector&lt;Int&gt;()<br>&nbsp;&nbsp; var accum = 0<br>&nbsp;&nbsp; for x in xs do :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; accum = accum + x<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add(ys, accum)<br>&nbsp;&nbsp; ys</code></pre><h2 id="anchor64">Lazy Sequences</h2><p>Our <code>cum-sum</code> function takes a sequence as its argument and returns a vector. This works just fine if we want <span style="font-style:italic;">all</span> of the cumulative sums, but what if we want only the first four? Then we&#39;re spending a lot of time computing results that we don&#39;t need. </p><p>To overcome this, we can rewrite <code>cum-sum</code> to return a <code>Seq&lt;Int&gt;</code> instead of a <code>Vector&lt;Int&gt;</code> where the elements in the returned sequence is computed <span style="font-style:italic;">on-demand</span>. </p><pre><code>defn cum-sum (xs:Seqable&lt;Int&gt;) :<br>&nbsp;&nbsp; var accum = 0<br>&nbsp;&nbsp; val xs-seq = to-seq(xs)<br>&nbsp;&nbsp; new Seq&lt;Int&gt; :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod empty? (this) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; empty?(xs-seq)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod peek (this) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; accum + peek(xs-seq)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod next (this) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; accum = peek(this)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next(xs-seq)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; accum</code></pre><p>Now <code>cum-sum</code> returns a <span style="font-style:italic;">lazy</span> sequence where items are computed as they&#39;re needed. To demonstrate this, let&#39;s call <code>cum-sum</code> on an <span style="font-style:italic;">infinite</span> range of numbers, and print out the first 10 elements.</p><pre><code>defn main () :<br>&nbsp;&nbsp; val xs = 1 to false by 3<br>&nbsp;&nbsp; val ys = cum-sum(xs)<br>&nbsp;&nbsp; for i in 0 to 10 do :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println(&quot;Item %_ is %_.&quot; % [i, next(ys)])<br><br>main()</code></pre><p>Compiling and running the above gives us</p><pre><code>Item 0 is 1.<br>Item 1 is 5.<br>Item 2 is 12.<br>Item 3 is 22.<br>Item 4 is 35.<br>Item 5 is 51.<br>Item 6 is 70.<br>Item 7 is 92.<br>Item 8 is 117.<br>Item 9 is 145.</code></pre><p>Thus <code>ys</code> is an <span style="font-style:italic;">infinite</span> sequence of integers containing the cumulative sum of another infinite sequence of integers. </p><h3 id="anchor251">seq</h3><p>Creating a sequence by calling a function repeatedly on the items from another sequence is a common operation, so it is included in Stanza&#39;s core library as the <code>seq</code> operating function. The <code>cum-sum</code> function can be rewritten using <code>seq</code> like this.</p><pre><code>defn cum-sum (xs:Seqable&lt;Int&gt;) :<br>&nbsp;&nbsp; var accum = 0<br>&nbsp;&nbsp; for x in xs seq :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; accum = accum + x<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; accum</code></pre><h2 id="anchor65">Using The Sequence Library</h2><p>Now that we&#39;ve been introduced to sequences, we can unveil the full power of Stanza&#39;s core library. As mentioned in an earlier chapter, Stanza encourages users to architect their programs by defining a small set of fundamental operations on each type, and then augment that with a large library of derived operations for those types. Stanza&#39;s sequence library is structured in such a way.</p><p>The set of fundamental operations for a <code>Seq</code> is very small, comprised of just <code>empty?</code>, <code>peek</code>, and <code>next</code>. But Stanza includes a large library of useful functions for manipulating sequences. These functions are roughly categorized into three groups: sequence creators, sequence operators, and sequence reducers. Independently of this categorization, a large number of these functions are also <span style="font-style:italic;">operating functions</span> and can be used with the for construct.</p><h3 id="anchor252">Sequence Creators</h3><p>Sequence creators are functions that take non-<code>Seq</code> arguments and create and return <code>Seq</code> objects. In typical programming, most sequences you manipulate will have been created with a sequence creator.</p><h3 id="anchor253">to-seq</h3><p>The most commonly used sequence creator is the <code>to-seq</code> function, which works on any <code>Seqable</code> object. You&#39;ve already seen usages of it for converting tuples, arrays, vectors, and ranges to sequences.</p><h3 id="anchor254">repeatedly</h3><p><code>repeatedly</code> takes an argument function, <code>f</code>, and creates an infinite sequence from the results of calling <code>f</code> repeatedly. Here is an example of using it to create a sequence containing all the positive powers of 2. </p><pre><code>var x = 1L<br>val xs = repeatedly $ fn () :<br>&nbsp;&nbsp; val cur-x = x<br>&nbsp;&nbsp; x = x * 2L<br>&nbsp;&nbsp; cur-x</code></pre><p>Let&#39;s print out the first 10 elements.</p><pre><code>do(println{next(xs)}, 0 to 10)</code></pre><p>which prints out</p><pre><code>1<br>2<br>4<br>8<br>16<br>32<br>64<br>128<br>256<br>512</code></pre><h3 id="anchor255">repeat-while</h3><p><code>repeat-while</code> takes an argument function, <code>f</code>, and creates an infinite sequence by calling <code>f</code> repeatedly. <code>f</code> must return a <code>Maybe</code> object. The returned sequence contains all the wrapped objects in all the <code>One</code> objects returned by <code>f</code> and ends the first time <code>f</code> returns a <code>None</code> object.</p><p>Here is an example of using it to create a sequence containing all the positive powers of 2 that are less than 2000.</p><pre><code>var x = 1L<br>var xs = repeat-while $ fn () :<br>&nbsp;&nbsp; val cur-x = x<br>&nbsp;&nbsp; if cur-x &lt; 2000L :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = x * 2L<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; One(cur-x)<br>&nbsp;&nbsp; else :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None()</code></pre><p>Let&#39;s print out all the items in <code>xs</code>.</p><pre><code>do(println, xs)</code></pre><p>which prints out</p><pre><code>1<br>2<br>4<br>8<br>16<br>32<br>64<br>128<br>256<br>512<br>1024</code></pre><h3 id="anchor256">Sequence Operators</h3><p>Sequence operators are functions that take <code>Seq</code> (or <code>Seqable</code>) arguments and create and return <code>Seq</code> objects. The lazy <code>cum-sum</code> function that we implemented is an example of a sequence operator. </p><h3 id="anchor257">cat</h3><p>One of the simplest sequence operators is the <code>cat</code> function which simply concatenates two sequences together to form a longer sequence.</p><p>Here is an example.</p><pre><code>val xs = [&quot;Patrick&quot;, &quot;Luca&quot;, &quot;Emmy&quot;]<br>val ys = [&quot;Sunny&quot;, &quot;Whiskey&quot;, &quot;Rummy&quot;]<br>val zs = cat(xs, ys)<br>do(println, zs)</code></pre><p>which prints out</p><pre><code>Patrick<br>Luca<br>Emmy<br>Sunny<br>Whiskey<br>Rummy</code></pre><h3 id="anchor258">join</h3><p><code>join</code> is another simple sequence operator that takes a sequence, <code>xs</code>, and a joiner item, <code>x</code>, and creates a <span style="font-style:italic;">lazy</span> sequence by inserting <code>x</code> in between each item in <code>xs</code>.</p><p>Here is an example.</p><pre><code>val xs = [&quot;Patrick&quot;, &quot;Luca&quot;, &quot;Emmy&quot;]<br>val zs = join(xs, &quot;and&quot;)<br>do(println, zs)</code></pre><p>which prints out</p><pre><code>Patrick<br>and<br>Luca<br>and<br>Emmy</code></pre><h3 id="anchor259">take-n</h3><p>The <code>take-n</code> function takes an integer, <code>n</code>, and a sequence, <code>xs</code>, and returns a <span style="font-style:italic;">lazy</span> sequence consisting of the first <code>n</code> elements in <code>xs</code>. It is a fatal error to call <code>take-n</code> on a sequence with less than <code>n</code> items.</p><p>Here is an example of using <code>take-n</code> to print out the first 10 items in an infinite range.</p><pre><code>val xs = 0 to false by 13<br>do(println, take-n(10, xs))</code></pre><p>which prints out</p><pre><code>0<br>13<br>26<br>39<br>52<br>65<br>78<br>91<br>104<br>117</code></pre><h3 id="anchor260">filter</h3><p>The <code>filter</code> function takes a predicate function, <code>f</code>, and a sequence, <code>xs</code>, and returns a <span style="font-style:italic;">lazy</span> sequence consisting only of the items in <code>xs</code> for which calling <code>f</code> on them returns <code>true</code>. <code>filter</code> is also an operating function.</p><p>Here is an example of using <code>filter</code> to print out only the positive items in a sequence.</p><pre><code>val xs = [1, 3, -2, -7, 3, -8, 9, 10, -3]<br>val ys = filter({_ &gt; 0}, xs)<br>do(println, ys)&nbsp;&nbsp;&nbsp;</code></pre><p>which prints out</p><pre><code>1<br>3<br>3<br>9<br>10</code></pre><h3 id="anchor261">seq</h3><p>The <code>seq</code> function is the most commonly used sequence operator. It takes a function, <code>f</code>, and a sequence, <code>xs</code>, and returns a <span style="font-style:italic;">lazy</span> sequence comprised of the results of calling <code>f</code> on each item in the sequence.</p><p>Here is an example of printing out the length of each string in a sequence.</p><pre><code>val xs = [&quot;Patrick&quot;, &quot;Luca&quot;, &quot;Emmy&quot;, &quot;Sunny&quot;, &quot;Whiskey&quot;, &quot;Rummy&quot;]<br>val ys = seq(length, xs)<br>do(println, ys)</code></pre><p>which prints out</p><pre><code>7<br>4<br>4<br>5<br>7<br>5</code></pre><h3 id="anchor262">Sequence Reducers</h3><p>Sequence reducers are functions that take <code>Seq</code> (or <code>Seqable</code>) arguments and return non-<code>Seq</code> objects. </p><p>We have already been introduced to and have been using a number of these, such as <code>do</code>, <code>find</code>, <code>first</code>, <code>index-when</code>, <code>all?</code>, <code>none?</code>, and <code>any?</code>. We&#39;ll take this opportunity to say that they each accept any <code>Seqable</code> object as their argument. </p><p>We&#39;ll show you a handful more useful reducers here, but you are encouraged to read the reference documentation for a listing of all of them. </p><h3 id="anchor263">contains?</h3><p><code>contains?</code> takes a sequence, <code>xs</code>, and an item, <code>y</code>, and returns <code>true</code> if <code>xs</code> contains <code>y</code>. Otherwise it returns <code>false</code>.</p><pre><code>val xs = [&quot;Patrick&quot;, &quot;Luca&quot;, &quot;Emmy&quot;]<br>println(contains?(xs, &quot;Emmy&quot;))<br>println(contains?(xs, &quot;Emily&quot;))</code></pre><p>prints out</p><pre><code>true<br>false</code></pre><h3 id="anchor264">index-of</h3><p><code>index-of</code> takes a sequence, <code>xs</code>, and an item, <code>y</code>, and returns the index of the first occurrence of <code>y</code> in <code>xs</code>. If <code>y</code> never appears in <code>xs</code>, then <code>false</code> is returned.</p><pre><code>val xs = [&quot;Patrick&quot;, &quot;Luca&quot;, &quot;Emmy&quot;]<br>println(index-of(xs, &quot;Emmy&quot;))<br>println(index-of(xs, &quot;Emily&quot;))</code></pre><p>prints out</p><pre><code>2<br>false</code></pre><h3 id="anchor265">unique</h3><p><code>unique</code> takes a sequence, <code>xs</code>, and returns a <span style="font-style:italic;">list</span> containing all the items in <code>xs</code> but with duplicates removed. </p><pre><code>val xs = [&quot;Patrick&quot;, &quot;Luca&quot;, &quot;Luca&quot;, &quot;Emmy&quot;, &quot;Patrick&quot;, &quot;Emmy&quot;]<br>println(unique(xs))</code></pre><p>prints out</p><pre><code>(&quot;Patrick&quot; &quot;Luca&quot; &quot;Emmy&quot;)</code></pre><h3 id="anchor266">to-array</h3><p><code>to-array</code> creates a new array containing all the items in its given sequence. It takes a single <span style="font-style:italic;">type argument</span> to indicate the element type of the array. We will discuss type arguments when we introduce parametric polymorphism. </p><p>Here is an example.</p><pre><code>val xs = [&quot;Patrick&quot;, &quot;Luca&quot;, &quot;Emmy&quot;]<br>println(to-array&lt;String&gt;(xs))</code></pre><p>prints out</p><pre><code>[&quot;Patrick&quot; &quot;Luca&quot; &quot;Emmy&quot;]</code></pre><h3 id="anchor267">to-vector</h3><p><code>to-vector</code> creates a new vector containing all the items in its given sequence. Like <code>to-array</code>, it also takes a single type argument to indicate the element type of the vector. </p><p>Here is an example.</p><pre><code>val xs = [&quot;Patrick&quot;, &quot;Luca&quot;, &quot;Emmy&quot;]<br>println(to-vector&lt;String&gt;(xs))</code></pre><h3 id="anchor268">to-list</h3><p><code>to-list</code> creates a new <span style="font-style:italic;">list</span> containing all the items in its given sequence. Note that unlike <code>to-array</code> and <code>to-vector</code>, <code>to-list</code> does <span style="font-style:italic;">not</span> take a type argument. We will cover lists in more detail when we talk about programming with immutable datastructures. For now, you can treat them just as another type of collection. And we will explain why <code>to-list</code> does not require a type argument in the chapter on parametric polymorphism.</p><p>Here is an example.</p><pre><code>val xs = [&quot;Patrick&quot;, &quot;Luca&quot;, &quot;Emmy&quot;]<br>println(to-list(xs))</code></pre><p>which prints out</p><pre><code>(&quot;Patrick&quot; &quot;Luca&quot; &quot;Emmy&quot;)</code></pre><h3 id="anchor269">reduce</h3><p><code>reduce</code> takes a binary operator, <code>f</code>, an initial item, <code>x0</code>, and a sequence, <code>xs</code>. If <code>xs</code> is empty then <code>reduce</code> returns <code>x0</code>. If <code>xs</code> contains one item, then <code>reduce</code> returns the result of calling <code>f</code> on <code>x0</code> and the item in <code>xs</code>. If <code>xs</code> contains two items, then <code>reduce</code> returns the result of calling <code>f</code> on <code>x0</code> and the first item in <code>xs</code>, and then calling <code>f</code> again on that result and the second item in <code>xs</code>. If <code>xs</code> contains three items, then <code>reduce</code> returns the result of calling <code>f</code> on <code>x0</code> and the first item in <code>xs</code>, then calling <code>f</code> again on that result and the second item in <code>xs</code>, and then calling <code>f</code> again on that result and the third item in <code>xs</code>. Et cetera. </p><p>Here is an example of using the <code>bit-or</code> operator to compute the bitwise or of every integer in a tuple.</p><pre><code>val xs = [1, 5, 18, 92, 1, 3]<br>val y = reduce(bit-or, 0, xs)<br>println(y)</code></pre><p>which prints out</p><pre><code>95</code></pre><h2 id="anchor66">Collection versus Seqable</h2><p>Consider the following definition of <code>print-odd-then-even</code>, a function that first prints all the odd integers in a sequence, and then prints all the even integers in the sequence.</p><pre><code>defn print-odd-then-even (xs:Seqable&lt;Int&gt;) :<br>&nbsp;&nbsp; val odd = filter({_ % 2 != 0}, xs)<br>&nbsp;&nbsp; val even = filter({_ % 2 == 0}, xs)<br>&nbsp;&nbsp; print(&quot;Odd integers: &quot;)<br>&nbsp;&nbsp; println-all(join(odd, &quot;, &quot;))<br>&nbsp;&nbsp; print(&quot;Even integers: &quot;)<br>&nbsp;&nbsp; println-all(join(even, &quot;, &quot;))</code></pre><p>Because we declared <code>print-odd-then-even</code> to accept an argument of type <code>Seqable</code>, we are able to call it on a variety of different types of collections. Let&#39;s try a few.</p><pre><code>defn main () :<br>&nbsp;&nbsp; val xs = [1, 2, 3, 4, 5, 6, 7, 8]<br>&nbsp;&nbsp; val ys = to-array&lt;Int&gt;([1, 2, 3, 4, 5, 6, 7, 8])<br>&nbsp;&nbsp; val zs = to-vector&lt;Int&gt;([1, 2, 3, 4, 5, 6, 7, 8])<br>&nbsp;&nbsp; val ws = 1 through 8<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; println(&quot;On tuples&quot;)<br>&nbsp;&nbsp; print-odd-then-even(xs)<br><br>&nbsp;&nbsp; println(&quot;On arrays&quot;)<br>&nbsp;&nbsp; print-odd-then-even(ys)<br><br>&nbsp;&nbsp; println(&quot;On vectors&quot;)<br>&nbsp;&nbsp; print-odd-then-even(zs)<br><br>&nbsp;&nbsp; println(&quot;On ranges&quot;)<br>&nbsp;&nbsp; print-odd-then-even(ws)<br><br>main()&nbsp;&nbsp;&nbsp;</code></pre><p>It prints out</p><pre><code>On tuples<br>Odd integers: 1, 3, 5, 7<br>Even integers: 2, 4, 6, 8<br>On arrays<br>Odd integers: 1, 3, 5, 7<br>Even integers: 2, 4, 6, 8<br>On vectors<br>Odd integers: 1, 3, 5, 7<br>Even integers: 2, 4, 6, 8<br>On ranges<br>Odd integers: 1, 3, 5, 7<br>Even integers: 2, 4, 6, 8</code></pre><p>demonstrating that it does the same thing regardless of the type of collection. </p><p>But now let&#39;s try calling it on a <code>Seq</code>. All <code>Seq</code> objects are also trivially instances of <code>Seqable</code>. Calling <code>to-seq</code> on a <code>Seq</code> object simply returns itself. </p><pre><code>defn main2 () :<br>&nbsp;&nbsp; val xs = to-seq(1 through 8)<br>&nbsp;&nbsp; println(&quot;On seqs&quot;)<br>&nbsp;&nbsp; print-odd-then-even(xs)<br><br>main2()</code></pre><p>This print outs</p><pre><code>On seqs<br>Odd integers: 1, 3, 5, 7<br>Even integers:&nbsp;</code></pre><p>What is happening? How come the even integers didn&#39;t get printed out? </p><p>The problem lies in the two calls to <code>filter</code>.</p><pre><code>val odd = filter({_ % 2 != 0}, xs)<br>val even = filter({_ % 2 == 0}, xs)</code></pre><p><code>filter</code> creates a lazy sequence, so iterating over the result of <code>filter</code> also requires iterating over the sequence it was constructed from. Thus printing out <code>odd</code> also requires iterating over <code>xs</code>, in which case, after printing out all the odd integers, we will have iterated through <code>xs</code> once completely and it will now be empty. At this point, <code>even</code> is also empty, as the sequence it was constructed from is now empty.</p><p>The fundamental problem is that <code>Seq</code> is a subtype of <code>Seqable</code>. Calling <code>to-seq</code> twice on a <code>Seq</code> object does <span style="font-style:italic;">not</span> return two independent sequences. For these purposes, Stanza provides a subtype of <code>Seqable</code> called <code>Collection</code>. Identical to <code>Seqable</code>, <code>to-seq</code> is the only fundamental operation supported by <code>Collection</code>. The crucial difference is that <code>Seq</code> is not a subtype of <code>Collection</code>. This means that each call to <code>to-seq</code> on a <code>Collection</code> returns an independent sequence. </p><p>Let&#39;s rewrite our <code>print-odd-then-even</code> function with the appropriate type annotation.</p><pre><code>defn print-odd-then-even (xs:Collection&lt;Int&gt;) :<br>&nbsp;&nbsp; val odd = filter({_ % 2 != 0}, xs)<br>&nbsp;&nbsp; val even = filter({_ % 2 == 0}, xs)<br>&nbsp;&nbsp; print(&quot;Odd integers: &quot;)<br>&nbsp;&nbsp; println-all(join(odd, &quot;, &quot;))<br>&nbsp;&nbsp; print(&quot;Even integers: &quot;)<br>&nbsp;&nbsp; println-all(join(even, &quot;, &quot;))</code></pre><p>You may verify that calling <code>print-odd-then-even</code> with all the collections in <code>main</code> still behaves as before. The important point is that attempting to compile <code>main2</code> now gives this error.</p><pre><code>Cannot call function print-odd-then-even of type Collection&lt;Int&gt; -&gt; False<br>with arguments of type (Seq&lt;Int&gt;).</code></pre><p>With the appropriate type annotation, Stanza now prevents us from calling <code>print-odd-then-even</code> incorrectly.</p><p>As a rule of thumb, you should always write your functions to accept <code>Collection</code> objects by default. If you are sure that you iterate through the sequence only once, then you may change it to accept <code>Seqable</code> objects in order to be able to pass it a <code>Seq</code>.</p><h2 id="anchor67">Revisiting Stack</h2><p>Let us now revisit our <code>Stack</code> type from chapter 4. Here is a (slightly cleaned up) listing of its definitions.</p><pre><code>deftype Stack<br>defmulti push (s:Stack, x:String) -&gt; False<br>defmulti pop (s:Stack) -&gt; String<br>defmulti empty? (s:Stack) -&gt; True|False<br><br>defn Stack (capacity:Int) -&gt; Stack :<br>&nbsp;&nbsp; val items = Array&lt;String&gt;(capacity)<br>&nbsp;&nbsp; var size = 0<br>&nbsp;&nbsp; new Stack :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod push (this, x:String) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if size == capacity : fatal(&quot;Stack is full!&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; items[size] = x<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size = size + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod pop (this) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if size == 0 : fatal(&quot;Stack is empty!&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size = size - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; items[size]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod empty? (this) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size == 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod print (o:OutputStream, this) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(o, &quot;Stack containing [&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print-all(o, join(take-n(size, items), &quot; &quot;))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(o, &quot;]&quot;)</code></pre><p>It&#39;s quite a basic definition, allowing us to push and pop items but not much else. We cannot find the index of a specific item, or determine whether it contains any capitalized strings, or get a listing of all of its unique elements. We cannot even iterate through it. The following</p><pre><code>val s = Stack(10)<br>push(s, &quot;Timon&quot;)<br>push(s, &quot;and&quot;)<br>push(s, &quot;Pumbaa&quot;)<br><br>for x in s do :<br>&nbsp;&nbsp; println(x)</code></pre><p>gives us this error if we try to compile it.</p><pre><code>No appropriate function do for arguments<br>of type (? -&gt; False, Stack). Possibilities are:<br>&nbsp;&nbsp; do: &lt;?T&gt; . (T -&gt; ?, Seqable&lt;?T&gt;) -&gt; False<br>&nbsp;&nbsp; do: &lt;?T, ?S&gt; . ((T, S) -&gt; ?,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Seqable&lt;?T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Seqable&lt;?S&gt;) -&gt; False<br>&nbsp;&nbsp; do: &lt;?T, ?S, ?U&gt; . ((T, S, U) -&gt; ?, Seqable&lt;?T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Seqable&lt;?S&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Seqable&lt;?U&gt;) -&gt; False</code></pre><p>It says that there are multiple definitions of <code>do</code> but all of them require a <code>Seqable</code> argument, and <code>Stack</code> is not a <code>Seqable</code>.&nbsp; </p><p>We shall extend the functionality of <code>Stack</code> by declaring it as a subtype of <code>Collection</code>. </p><pre><code>deftype Stack &lt;: Collection&lt;String&gt;</code></pre><p>The mandatory minimal implementation of <code>Collection</code> is <code>to-seq</code>, so we need to now provide a method for it. Here is now our extended <code>Stack</code> construction function.</p><pre><code>defn Stack (capacity:Int) -&gt; Stack :<br>&nbsp;&nbsp; val items = Array&lt;String&gt;(capacity)<br>&nbsp;&nbsp; var size = 0<br>&nbsp;&nbsp; new Stack :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod push (this, x:String) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if size == capacity : fatal(&quot;Stack is full!&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; items[size] = x<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size = size + 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod pop (this) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if size == 0 : fatal(&quot;Stack is empty!&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size = size - 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; items[size]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod empty? (this) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size == 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod print (o:OutputStream, this) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(o, &quot;Stack containing [&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print-all(o, join(this, &quot; &quot;))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(o, &quot;]&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod to-seq (this) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; take-n(size, items)</code></pre><p>Our implementation of <code>to-seq</code> simply calls <code>take-n</code> to retrieve the first <code>size</code> elements from the backing array <code>items</code>.</p><p>Now let&#39;s try exercising the power of our new extended <code>Stack</code> type. </p><pre><code>defn main () :<br>&nbsp;&nbsp; val s = Stack(10)<br>&nbsp;&nbsp; for x in [&quot;Timon&quot;, &quot;Timon&quot;, &quot;and&quot;, &quot;Pumbaa&quot;, &quot;Pumbaa&quot;] do :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push(s, x)<br><br>&nbsp;&nbsp; println(&quot;1. Contents of s&quot;)<br>&nbsp;&nbsp; println(s)<br><br>&nbsp;&nbsp; println(&quot;\n2. Index of Pumbaa&quot;)<br>&nbsp;&nbsp; println(index-of(s, &quot;Pumbaa&quot;))<br><br>&nbsp;&nbsp; println(&quot;\n3. Does it contain any capitalized strings?&quot;)<br>&nbsp;&nbsp; println(any?(upper-case?{_[0]}, s))<br><br>&nbsp;&nbsp; println(&quot;\n4. Are all strings capitalized?&quot;)<br>&nbsp;&nbsp; println(all?(upper-case?{_[0]}, s))<br><br>&nbsp;&nbsp; println(&quot;\n5. What are the capitalized strings?&quot;)<br>&nbsp;&nbsp; val cap-s = filter(upper-case?{_[0]}, s)<br>&nbsp;&nbsp; println-all(join(cap-s, &quot;, &quot;))<br><br>&nbsp;&nbsp; println(&quot;\n6. What are its unique elements?&quot;)<br>&nbsp;&nbsp; println(unique(s))<br><br>main()</code></pre><p>Compiling and running the above prints out</p><pre><code>1. Contents of s<br>Stack containing [Timon Timon and Pumbaa Pumbaa]<br><br>2. Index of Pumbaa<br>3<br><br>3. Does it contain any capitalized strings?<br>true<br><br>4. Are all strings capitalized?<br>false<br><br>5. What are the capitalized strings?<br>Timon, Timon, Pumbaa, Pumbaa<br><br>6. What are its unique elements?<br>(&quot;Timon&quot; &quot;and&quot; &quot;Pumbaa&quot;)</code></pre><p>This example shows us the full advantage of structuring your programs to contain a large library of derived operations. With a two line change to our definition of the <code>Stack</code> object, we&#39;ve provided it the full capabilities of Stanza&#39;s sequence library.&nbsp; </p>
        </td>
        <td class="rest">
          <img url="resources/spacer.gif"></img>
        </td>
      </tr>
      <tr><td colspan="3" class="footer">
        Site design by Luca Li. Copyright 2015.
      </td></tr>
    </table>
  </body>
</html>
