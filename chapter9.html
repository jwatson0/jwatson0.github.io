
<!DOCTYPE html>
<html>
  <head>
    <title>L.B.Stanza</title>
    <link type="text/css" rel="stylesheet" href="resources/mainstyle.css">
    <link type="text/css" rel="stylesheet" href="resources/documentation.css">
  </head>
  <body>
    <table class="wrap">
      <tr><td colspan="3" class="banner">
        <a href="index.html">Home</a><a href="stanzabyexample.html">Table of Contents</a><a href="chapter8.html">Previous Chapter</a><a href="macrosystem.html">Next Chapter</a>
      </td></tr>
      <tr>
        <td class="nav">
          <h1>NAVIGATION</h1>
          <h2><a href="#anchor308">Advanced Control Flow</a></h2><h3><a href="#anchor79">First Class Labeled Scopes</a></h3><h4><a href="#anchor309">Pulling Out the Body</a></h4><h4><a href="#anchor310">Storing the Exit Function</a></h4><h3><a href="#anchor80">Dynamic Wind</a></h3><h3><a href="#anchor81">Dynamically Scoped Variables</a></h3><h3><a href="#anchor82">Attempts and Failures</a></h3><h3><a href="#anchor83">Example: S-Expression Parser</a></h3><h4><a href="#anchor311">Overall Structure</a></h4><h4><a href="#anchor312">Helper Functions</a></h4><h4><a href="#anchor313">Parsing Symbols</a></h4><h4><a href="#anchor314">Parsing Numbers</a></h4><h4><a href="#anchor315">Parsing Sequences</a></h4><h4><a href="#anchor316">Parsing Lists</a></h4><h4><a href="#anchor317">Driver</a></h4><h4><a href="#anchor318">Listing</a></h4><h4><a href="#anchor319">Trying it Out</a></h4><h4><a href="#anchor320">Unveiling The Internals</a></h4><h3><a href="#anchor84">Exception Handling</a></h3><h4><a href="#anchor321">Exception Objects</a></h4><h4><a href="#anchor322">Throwing Exceptions</a></h4><h4><a href="#anchor323">Catching Exceptions</a></h4><h3><a href="#anchor85">Generators</a></h3><h4><a href="#anchor324">The Ability to Resume</a></h4><h4><a href="#anchor325">General Form</a></h4><h4><a href="#anchor326">Example: Flattening a Tuple</a></h4><h3><a href="#anchor86">Coroutines</a></h3><h4><a href="#anchor327">Sending Things Out</a></h4><h4><a href="#anchor328">Breaking Things Off</a></h4><h4><a href="#anchor329">Sending Things In</a></h4><h4><a href="#anchor330">Closing Things Off</a></h4><h4><a href="#anchor331">Checking a Coroutine's Status</a></h4><h4><a href="#anchor332">Nested Coroutines</a></h4><h3><a href="#anchor87">Example: Key Listener</a></h3><h4><a href="#anchor333">Coroutine Framework</a></h4><h4><a href="#anchor334">Buffer Managing Routines</a></h4><h4><a href="#anchor335">Dispatch Mode</a></h4><h4><a href="#anchor336">Word Mode</a></h4><h4><a href="#anchor337">String Mode</a></h4><h4><a href="#anchor338">Testing the KeyListener</a></h4>
        </td>
        <td class="main">
          <h1 id="anchor308">Advanced Control Flow</h1><p>Thus far, the only control flow mechanism you&#39;ve been shown was the <code>label</code> construct for creating labeled scopes. But this one construct was powerful enough to express early returns from functions, early breaks from loops, and also (though we haven&#39;t shown it) early jumps to the next loop iteration. Each of the above functionality has traditionally been a separate keyword and language feature in other languages, but they&#39;re all expressible with just the <code>label</code> construct in Stanza. It is a powerful and general mechanism.</p><p>In actuality, Stanza only has a single control flow mechanism, called <span style="font-style:italic;">targetable coroutines</span>. The <code>label</code> construct is just a common usage pattern for them. In this chapter we&#39;ll learn about the other common usage pattern of coroutines: attempts and failures, exception handlers, and generators. At the very end, we&#39;ll show you the general coroutine construct, along with some examples demonstrating their use.</p><h2 id="anchor79">First Class Labeled Scopes</h2><p>Here is a function that finds the smallest power of two that is greater or equal to the given argument, <code>n</code>.</p><pre><code>defn min-pow-2 (n:Int) :<br>&nbsp;&nbsp; label&lt;Int&gt; return :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var x = 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while true :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if x &gt;= n : return(x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = x * 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fatal(&quot;Unreachable&quot;)&nbsp;&nbsp;&nbsp;</code></pre><p>Let&#39;s try it out.</p><pre><code>defn main () :<br>&nbsp;&nbsp; defn test (n:Int) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println(&quot;The minimum power of 2 greater or equal to %_ is %_.&quot; %<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [n, min-pow-2(n)])<br>&nbsp;&nbsp; test(10)<br>&nbsp;&nbsp; test(100)<br>&nbsp;&nbsp; test(1000)<br>&nbsp;&nbsp; test(10000)<br>&nbsp;&nbsp; test(100000)<br>&nbsp;&nbsp; test(1000000)<br><br>main()</code></pre><p>Compiling and running the above prints out</p><pre><code>The minimum power of 2 greater or equal to 10 is 16.<br>The minimum power of 2 greater or equal to 100 is 128.<br>The minimum power of 2 greater or equal to 1000 is 1024.<br>The minimum power of 2 greater or equal to 10000 is 16384.<br>The minimum power of 2 greater or equal to 100000 is 131072.<br>The minimum power of 2 greater or equal to 1000000 is 1048576.</code></pre><h3 id="anchor309">Pulling Out the Body</h3><p>That&#39;s fairly standard so far. But now let&#39;s pull out the body of the while loop into a separate function, called <code>pow-2?</code>. It accepts an argument, <code>x</code>, that is the current number being tested, an argument, <code>n</code>, as the limit we&#39;re trying to reach, and also a function called <code>return</code>, which we&#39;ll explain later.</p><pre><code>defn pow-2? (x:Int, n:Int, return:Int -&gt; Void) -&gt; Int :<br>&nbsp;&nbsp; if x &gt;= n : return(x)<br>&nbsp;&nbsp; else : x * 2</code></pre><p><code>pow-2?</code> first checks whether <code>x</code> is greater or equal to <code>n</code>, and calls <code>return</code> with <code>x</code> if it is. Otherwise it returns the next value of <code>x</code> to <code>test</code>, which is <code>x * 2</code>.</p><p>We now update the <code>min-pow-2</code> function to call <code>pow-2?</code>.</p><pre><code>defn min-pow-2 (n:Int) :<br>&nbsp;&nbsp; label&lt;Int&gt; return :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var x = 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while true :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = pow-2?(x, n, return)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fatal(&quot;Unreachable&quot;)</code></pre><p>Compile and run the program to verify that it still works.</p><p>What is happening here!? We&#39;ve somehow passed the exit function out of <code>min-pow-2</code> and into <code>pow-2?</code>. Then when <code>pow-2?</code> called <code>return</code>, it returned not from <code>pow-2?</code>, but from <code>min-pow-2</code>!.</p><p>Let&#39;s review the definition of the <code>label</code> construct. Here is its general form.</p><pre><code>label&lt;T&gt; exit :<br>&nbsp;&nbsp; body</code></pre><p>The <code>label</code> construct requires the type it returns, <code>T</code>, the name of the exit function, <code>exit</code>, and the body to execute, <code>body</code>. <code>label</code> creates an exit function of type <code>T -&gt; Void</code> with the name <code>exit</code>, and then executes <code>body</code>. If <code>body</code> never calls the exit function then the result of <code>body</code> is returned by <code>label</code>. If <code>body</code> calls the exit function then <code>label</code> <span style="font-style:italic;">immediately</span> returns the argument passed to the exit function. The return type <code>Void</code> for the exit function indicates that it <span style="font-style:italic;">doesn&#39;t return</span> to its caller.</p><p>There is nothing in the description of <code>label</code> preventing us from passing out the exit function, so the call to <code>return</code> in <code>pow-2?</code> is simply causing the <code>label</code> construct to return <code>x</code>, which is then returned by <code>min-pow-2</code>.</p><h3 id="anchor310">Storing the Exit Function</h3><p>We can even store the exit function in a variable if we like. Here&#39;s a global variable</p><pre><code>var RETURN: Int -&gt; Void</code></pre><p>into which we will store the exit function. Thus the exit function will no longer be passed in to <code>pow-2?</code> as an argument.</p><pre><code>defn pow-2? (x:Int, n:Int) -&gt; Int :<br>&nbsp;&nbsp; if x &gt;= n : RETURN(x)<br>&nbsp;&nbsp; else : x * 2</code></pre><p>It will instead be stored in the global variable before <code>pow-2?</code> is called.</p><pre><code>defn min-pow-2 (n:Int) :<br>&nbsp;&nbsp; label&lt;Int&gt; return :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN = return<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var x = 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while true :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = pow-2?(x, n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fatal(&quot;Unreachable&quot;)</code></pre><p>Compile and verify that the program still works as before.</p><p>Here you&#39;re starting to see just how flexible the <code>label</code> construct really is. Storing the exit function seems like a strange thing to want to do but keep it in the back of your mind as we talk about the other constructs.</p><h2 id="anchor80">Dynamic Wind</h2><p>One of the issues that accompanies having a powerful control flow mechanism is that in a sequence of expressions, evaluating the first expression does not guarantee that the last one will be evaluated.</p><pre><code>f()<br>g()<br>h()</code></pre><p>For example, in the above sequence, even after <code>f</code> returns, there is no guarantee that <code>h</code> will be called. If <code>g</code> calls an exit function then <code>h</code> will be skipped entirely.</p><p>Let us suppose that we do not want to pass in the limit, <code>n</code>, as an argument to <code>pow-2?</code>. We would like to keep it stored in a global variable called <code>LIMIT</code> and set it to the appropriate value <span style="font-style:italic;">only during the call</span> to <code>pow-2?</code>. At all other times, <code>LIMIT</code> should retain its initial value of <code>0</code>. Here is an initial attempt.</p><pre><code>var LIMIT: Int = 0<br>var RETURN: Int -&gt; Void<br><br>defn pow-2? (x:Int) -&gt; Int :<br>&nbsp;&nbsp; if x &gt;= LIMIT : RETURN(x)<br>&nbsp;&nbsp; else : x * 2<br><br>defn min-pow-2 (n:Int) :<br>&nbsp;&nbsp; label&lt;Int&gt; return :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN = return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var x = 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while true :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val old-limit = LIMIT<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LIMIT = n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = pow-2?(x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LIMIT = old-limit<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fatal(&quot;Unreachable&quot;)<br><br>defn main () :<br>&nbsp;&nbsp; defn test (n:Int) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println(&quot;The minimum power of 2 greater or equal to %_ is %_.&quot; %<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [n, min-pow-2(n)])<br>&nbsp;&nbsp; test(10)<br>&nbsp;&nbsp; test(100)<br>&nbsp;&nbsp; test(1000)<br>&nbsp;&nbsp; test(10000)<br>&nbsp;&nbsp; test(100000)<br>&nbsp;&nbsp; test(1000000)<br><br>main()<br>println(&quot;After main, LIMIT is %_.&quot; % [LIMIT])</code></pre><p>Printing and compiling the above prints out</p><pre><code>The minimum power of 2 greater or equal to 10 is 16.<br>The minimum power of 2 greater or equal to 100 is 128.<br>The minimum power of 2 greater or equal to 1000 is 1024.<br>The minimum power of 2 greater or equal to 10000 is 16384.<br>The minimum power of 2 greater or equal to 100000 is 131072.<br>The minimum power of 2 greater or equal to 1000000 is 1048576.<br>After main, LIMIT is 1000000.</code></pre><p>So <code>min-pow-2</code> is working correctly, but <code>LIMIT</code> is not being restored back to its original value. What is happening? Well the call to <code>pow-2?</code> in</p><pre><code>LIMIT = n<br>x = pow-2?(x)<br>LIMIT = old-limit</code></pre><p>may call the exit function, <code>return</code>. If that happens, then the <code>label</code> construct immediately returns and the last <code>LIMIT = old-limit</code> expression is never evaluated. </p><p>Stanza provides the special function <code>dynamic-wind</code> to handle these situations. It allows you to surround a body of code between some <span style="font-style:italic;">wind in</span> and <span style="font-style:italic;">wind out</span> code. The wind in code is <span style="font-style:italic;">guaranteed</span> to execute whenever the control flow enters the body, and the wind out code is <span style="font-style:italic;">guaranteed</span> to execute whenever the control flow exits the body. Here is how it&#39;s used.</p><pre><code>defn min-pow-2 (n:Int) :<br>&nbsp;&nbsp; label&lt;Int&gt; return :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN = return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var x = 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while true :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val old-limit = LIMIT<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dynamic-wind(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fn () :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LIMIT = n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fn () :&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = pow-2?(x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fn (final) :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LIMIT = old-limit)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fatal(&quot;Unreachable&quot;)</code></pre><p>The wind in, body, and wind out code is given to <code>dynamic-wind</code> as three anonymous functions. The <code>final</code> argument for the wind out code is a boolean value that indicates whether it is guaranteed to be the last time the wind out code is called. In this example, <code>final</code> will always be <code>true</code>. </p><p>Now compiling and running the program again prints out</p><pre><code>The minimum power of 2 greater or equal to 10 is 16.<br>The minimum power of 2 greater or equal to 100 is 128.<br>The minimum power of 2 greater or equal to 1000 is 1024.<br>The minimum power of 2 greater or equal to 10000 is 16384.<br>The minimum power of 2 greater or equal to 100000 is 131072.<br>The minimum power of 2 greater or equal to 1000000 is 1048576.<br>After main, LIMIT is 0.</code></pre><p>indicating the <code>LIMIT</code> is properly being reset to its original value.</p><h2 id="anchor81">Dynamically Scoped Variables</h2><p>In the above example, we say that <code>LIMIT</code> is being used as a <span style="font-style:italic;">dynamically scoped</span> variable. This is a common pattern and Stanza provides a syntactic shorthand for our call to <code>dynamic-wind</code>.</p><p>Here is the <code>min-pow-2</code> function written using the <code>let-var</code> shorthand.</p><pre><code>defn min-pow-2 (n:Int) :<br>&nbsp;&nbsp; label&lt;Int&gt; return :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RETURN = return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var x = 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while true :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let-var LIMIT = n :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = pow-2?(x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fatal(&quot;Unreachable&quot;)</code></pre><p>The general form of <code>let-var</code> is</p><pre><code>let-var x = v :<br>&nbsp;&nbsp; body</code></pre><p>It temporarily sets the <code>x</code> variable to the value <code>v</code> before executing <code>body</code>. <code>x</code> is restored to its previous value after <code>body</code> is finished executing.</p><h2 id="anchor82">Attempts and Failures</h2><p>Attempts and failures are syntactic sugar for another use case of targetable coroutines that operate very similarly to labeled scopes. Here is an example.</p><pre><code>defn read-letter (xs:Seq&lt;Char&gt;) -&gt; Char :<br>&nbsp;&nbsp; if not letter?(peek(xs)) : fail()<br>&nbsp;&nbsp; next(xs)<br><br>defn read-digit (xs:Seq&lt;Char&gt;) -&gt; Char :<br>&nbsp;&nbsp; if not digit?(peek(xs)) : fail()<br>&nbsp;&nbsp; next(xs)<br><br>defn read-all (xs:Collection&lt;Char&gt;) :<br>&nbsp;&nbsp; val xs-seq = to-seq(xs)<br>&nbsp;&nbsp; while not empty?(xs-seq) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attempt : <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println(&quot;Read letter: %_&quot; % [read-letter(xs-seq)])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else attempt :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println(&quot;Read digit: %_&quot; % [read-digit(xs-seq)])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println(&quot;Read something else: %~&quot; % [next(xs-seq)])<br><br>read-all(&quot;42 is the answer.&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></pre><p>Compiling the above prints out</p><pre><code>Read digit: 4<br>Read digit: 2<br>Read something else: &#39; &#39;<br>Read letter: i<br>Read letter: s<br>Read something else: &#39; &#39;<br>Read letter: t<br>Read letter: h<br>Read letter: e<br>Read something else: &#39; &#39;<br>Read letter: a<br>Read letter: n<br>Read letter: s<br>Read letter: w<br>Read letter: e<br>Read letter: r<br>Read something else: &#39;.&#39;</code></pre><p>The function <code>read-all</code> calls <code>read-letter</code> and <code>read-digit</code> in an <code>attempt</code> block. If the block evaluates without ever calling <code>fail</code> then the result of the block is returned by <code>attempt</code>. If the block calls <code>fail</code>, then <code>attempt</code> <span style="font-style:italic;">immediately</span> returns the result of evaluating the code in the <code>else</code> branch.</p><h2 id="anchor83">Example: S-Expression Parser</h2><p>Here is an example of using <code>attempt</code> and <code>fail</code> to program a simple s-expression parser. An s-expression, in this case, will be defined as either</p><ol><li>a positive integer,
</li><li>a symbol consisting of letters,
</li><li>or a list containing more s-expressions.
</li></ol><h3 id="anchor311">Overall Structure</h3><p>Here is the basic structure of the parser.</p><pre><code>defn parse-sexp (sexp:String) -&gt; List :<br>&nbsp;&nbsp; val chars = to-seq(sexp)<br><br>&nbsp;&nbsp; defn eat-while (pred?: Char -&gt; True|False) -&gt; String :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br><br>&nbsp;&nbsp; defn eat-whitespace () -&gt; False :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... calls eat-while ...<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; defn parse-symbol () -&gt; Symbol :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... calls eat-while ...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp; defn parse-number () -&gt; Int :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... calls eat-while ...<br><br>&nbsp;&nbsp; defn parse-sequence () -&gt; List :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... calls eat-whitespace, parse-symbol, parse-number, and parse-list<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp; defn parse-list () -&gt; List :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... calls parse-list ...<br><br>&nbsp;&nbsp; parse-sequence()<br>&nbsp;&nbsp; ...</code></pre><p>parse-sexp is given a string, and returns a list of s-expressions. Upon entering the function, we ask to view the string as a sequence of characters, <code>chars</code>. <code>eat-while</code> and <code>eat-whitespace</code> are helper functions. <code>parse-symbol</code>, <code>parse-number</code>, <code>parse-sequence</code>, and <code>parse-list</code> are mutually recursive functions that parse symbols, numbers, sequences of s-expressions, and lists of s-expressions.</p><h3 id="anchor312">Helper Functions</h3><p>The <code>eat-while</code>, and <code>eat-whitespace</code> functions are helper functions for reading from <code>chars</code>. <code>eat-while</code> takes a predicate function, <code>pred?</code>, and eats characters from <code>chars</code> as long as <code>pred?</code> returns <code>true</code>. It returns a string containing the eaten characters. <code>eat-whitespace</code> eats all leading spaces in <code>chars</code>. Here are their definitions.</p><pre><code>defn eat-while (pred?: Char -&gt; True|False) -&gt; String :<br>&nbsp;&nbsp; string-join(take-while(pred?, chars))<br><br>defn eat-whitespace () -&gt; False :<br>&nbsp;&nbsp; eat-while({_ == &#39; &#39;})<br>&nbsp;&nbsp; false</code></pre><h3 id="anchor313">Parsing Symbols</h3><p>The <code>parse-symbol</code> function eats and returns the next symbol from <code>chars</code>. If the next character in <code>chars</code> is not a letter, then <code>parse-symbol</code> fails.</p><pre><code>defn parse-symbol () -&gt; Symbol :<br>&nbsp;&nbsp; if not letter?(peek(chars)) : fail()<br>&nbsp;&nbsp; to-symbol(eat-while(letter?))</code></pre><h3 id="anchor314">Parsing Numbers</h3><p>The <code>parse-number</code> function eats and returns the next positive integer from <code>chars</code>. If the next character in <code>chars</code> is not a digit, or if the number cannot be represented in 32 bits, then <code>parse-number</code> fails. </p><pre><code>defn parse-number () -&gt; Int :<br>&nbsp;&nbsp; if not digit?(peek(chars)) : fail()<br>&nbsp;&nbsp; val x = to-int(eat-while(digit?))<br>&nbsp;&nbsp; if x is-not Int : fail()<br>&nbsp;&nbsp; x as Int</code></pre><h3 id="anchor315">Parsing Sequences</h3><p>The <code>parse-sequence</code> function reads as many s-expressions as possible by calling <code>parse-symbol</code>, <code>parse-number</code>, and <code>parse-list</code> repeatedly.</p><pre><code>defn parse-sequence () -&gt; List :<br>&nbsp;&nbsp; eat-whitespace()<br>&nbsp;&nbsp; if empty?(chars) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List()<br>&nbsp;&nbsp; else :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attempt : cons(parse-symbol(), parse-sequence())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else attempt : cons(parse-number(), parse-sequence())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else attempt : cons(parse-list(), parse-sequence())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else : List()</code></pre><p>Notice the use of <code>attempt</code> to first try parsing a symbol, and then if that fails to then try parsing a number, followed by trying to parse a list. </p><h3 id="anchor316">Parsing Lists</h3><p>The <code>parse-list</code> function eats and returns the next list from <code>chars</code>. A list is simply a sequence of s-expressions surrounded by <code>()</code> characters. If the next character is not an opening parenthesis then <code>parse-list</code> fails.</p><pre><code>defn parse-list () -&gt; List :&nbsp;&nbsp; <br>&nbsp;&nbsp; if peek(chars) != &#39;(&#39; : fail()<br>&nbsp;&nbsp; next(chars)<br>&nbsp;&nbsp; val items = parse-sequence()<br>&nbsp;&nbsp; if empty?(chars) : fatal(&quot;Unclosed opening parenthesis.&quot;)<br>&nbsp;&nbsp; else if peek(chars) == &#39;)&#39; : (next(chars), items)<br>&nbsp;&nbsp; else : fatal(&quot;Expected closing parenthesis but got %~.&quot; % [next(chars)])</code></pre><h3 id="anchor317">Driver</h3><p>Finally, to start off the function, we attempt to read as many s-expressions as possible from <code>chars</code> using <code>parse-sequence</code>. </p><pre><code>val items = parse-sequence()<br>if empty?(chars) : items<br>else : fatal(&quot;Unexpected character: %~.&quot; % [next(chars)])</code></pre><h3 id="anchor318">Listing</h3><p>Here is the complete definition of <code>parse-sexp</code>.</p><pre><code>defn parse-sexp (sexp:String) :<br>&nbsp;&nbsp; val chars = to-seq(sexp)<br><br>&nbsp;&nbsp; defn eat-while (pred?: Char -&gt; True|False) -&gt; String :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string-join(take-while(pred?, chars))<br><br>&nbsp;&nbsp; defn eat-whitespace () -&gt; False :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eat-while({_ == &#39; &#39;})<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; false<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; defn parse-symbol () -&gt; Symbol :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not letter?(peek(chars)) : fail()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to-symbol(eat-while(letter?))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp; defn parse-number () -&gt; Int :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not digit?(peek(chars)) : fail()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val x = to-int(eat-while(digit?))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if x is-not Int : fail()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x as Int<br><br>&nbsp;&nbsp; defn parse-sequence () -&gt; List :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eat-whitespace()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if empty?(chars) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attempt : cons(parse-symbol(), parse-sequence())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else attempt : cons(parse-number(), parse-sequence())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else attempt : cons(parse-list(), parse-sequence())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else : List()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp; defn parse-list () -&gt; List :&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if peek(chars) != &#39;(&#39; : fail()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next(chars)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val items = parse-sequence()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if empty?(chars) : fatal(&quot;Unclosed opening parenthesis.&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if peek(chars) == &#39;)&#39; : (next(chars), items)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else : fatal(&quot;Expected closing parenthesis but got %~.&quot; % [next(chars)])<br><br>&nbsp;&nbsp; val items = parse-sequence()<br>&nbsp;&nbsp; if empty?(chars) : items<br>&nbsp;&nbsp; else : fatal(&quot;Unexpected character: %~.&quot; % [next(chars)])</code></pre><h3 id="anchor319">Trying it Out</h3><p>Let&#39;s try it out on the following string.</p><pre><code>do(println, parse-sexp(&quot;This (is) (commonly (called an (S) (Expression)))&quot;))</code></pre><p>When compiled and ran it prints out</p><pre><code>This<br>(is)<br>(commonly (called an (S) (Expression)))</code></pre><h3 id="anchor320">Unveiling The Internals</h3><p>The <code>attempt</code> construct is just syntactic sugar for a function call.</p><pre><code>attempt : conseq<br>else : alt</code></pre><p>is equivalent to</p><pre><code>with-attempt(<br>&nbsp;&nbsp; fn () : conseq<br>&nbsp;&nbsp; fn () : alt)</code></pre><p>As an exercise, try and implement your own <code>with-attempt</code> function by using the <code>label</code> construct.</p><h2 id="anchor84">Exception Handling</h2><p>Our s-expression parser from the previous example fails when called with invalid input (though with very nice error messages). Here is what happens if we forget a closing parenthesis at the end.</p><pre><code>do(println, parse-sexp(&quot;This (is) (commonly (called an (S) (Expression))&quot;))</code></pre><p>Compiling and running the above prints out</p><pre><code>FATAL ERROR: Unclosed opening parenthesis.<br>&nbsp;&nbsp; at test.stanza:39.25<br>&nbsp;&nbsp; at test.stanza:32.29<br>&nbsp;&nbsp; at core/core.stanza:3725.13<br>&nbsp;&nbsp; at core/core.stanza:847.16<br>&nbsp;&nbsp; at core/core.stanza:3724.14<br>&nbsp;&nbsp; ...</code></pre><p>But what if we cannot guarantee that the input is correct? Suppose we want users to type an arbitrary string into the terminal and print the parsed s-expression if it&#39;s well formed, or else ask them to try again if it&#39;s not.</p><p>A potential solution would be to write another function called <code>sexp?</code> that returns <code>true</code> or <code>false</code> depending on whether its argument is a well formed string. But checking whether an s-expression is well formed is almost as much work as parsing it, so that&#39;s an inefficient solution.</p><p>Stanza provides us a mechanism for handling this called <span style="font-style:italic;">exceptions</span>.</p><h3 id="anchor321">Exception Objects</h3><p>The first step is to declare our own <code>Exception</code> types, one for each type of error the parser can encounter.</p><pre><code>defstruct UnclosedParenthesis &lt;: Exception<br>defmethod print (o:OutputStream, e:UnclosedParenthesis) :<br>&nbsp;&nbsp; print(o, &quot;Unclosed opening parenthesis.&quot;)<br>&nbsp;&nbsp; <br>defstruct UnmatchedParenthesis &lt;: Exception : (char:Char)<br>defmethod print (o:OutputStream, e:UnmatchedParenthesis) :<br>&nbsp;&nbsp; print(o, &quot;Expected closing parenthesis but got %~.&quot; % [char(e)])<br>&nbsp;&nbsp; <br>defstruct UnexpectedCharacter &lt;: Exception : (char:Char)<br>defmethod print (o:OutputStream, e:UnexpectedCharacter) :<br>&nbsp;&nbsp; print(o, &quot;Unexpected character: %~.&quot; % [char(e)])</code></pre><p>There are three different errors that are detected by our parser. </p><ol><li>The string is missing a closing parenthesis at the end.
</li><li>We are currently reading a list and encountered a strange character.
</li><li>We've read as many s-expressions as possible and there is a strange character left over.
</li></ol><h3 id="anchor322">Throwing Exceptions</h3><p>The next step is to change the calls to <code>fatal</code> to calls to <code>throw</code> with our newly defined <code>Exception</code> objects.</p><pre><code>defn parse-sexp (sexp:String) :<br><br>&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp; defn parse-list () -&gt; List :&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if empty?(chars) : throw(UnclosedParenthesis())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if peek(chars) == &#39;)&#39; : (next(chars), items)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else : throw(UnmatchedParenthesis(next(chars)))<br><br>&nbsp;&nbsp; val items = parse-sequence()<br>&nbsp;&nbsp; if empty?(chars) : items<br>&nbsp;&nbsp; else : throw(UnexpectedCharacter(next(chars)))</code></pre><h3 id="anchor323">Catching Exceptions</h3><p>The final step is to <span style="font-style:italic;">catch</span> the thrown exceptions. We can decide which types of exceptions to catch, and which not to. In this example, we&#39;ll assume that the string doesn&#39;t contain any strange characters and catch only the unclosed parenthesis error.</p><pre><code>try :<br>&nbsp;&nbsp; do(println, parse-sexp(&quot;This (is) (commonly (called an (S) (Expression))&quot;))<br>catch (e:UnclosedParenthesis) :<br>&nbsp;&nbsp; println(&quot;You forgot to close an opening parenthesis. Please try again.&quot;)</code></pre><p>Compiling and running the program now prints out</p><pre><code>You forgot to close an opening parenthesis. Please try again.</code></pre><p>Here is the general form of the <code>try</code> construct.</p><pre><code>try :<br>&nbsp;&nbsp; body<br>catch (e:ExceptionA) :<br>&nbsp;&nbsp; a-handler<br>catch (e:ExceptionB) :<br>&nbsp;&nbsp; b-handler<br>...&nbsp;&nbsp;&nbsp;</code></pre><p>The <code>try</code> construct evaluates the given <code>body</code> after installing the given exception handlers. If <code>body</code> is evaluated without ever calling <code>throw</code> then its result is returned by <code>try</code>. If <code>body</code> calls <code>throw</code> with some <code>Exception</code> object, then <code>try</code> immediately searches for the first exception handler that can accept the <code>Exception</code> object and returns the result of evaluating that handler. </p><h2 id="anchor85">Generators</h2><p>The control flow constructs you&#39;ve been introduced to so far, labeled scopes, attempts and failures, and exceptions, have all served the purpose of <span style="font-style:italic;">leaving</span> a block of code. Generators are the first control flow construct you will learn capable of <span style="font-style:italic;">resuming</span> a block of code. </p><p>Here is a generator that <span style="font-style:italic;">yields</span> the first three positive integers.</p><pre><code>val xs:Seq&lt;Int&gt; = generate&lt;Int&gt; :<br>&nbsp;&nbsp; println(&quot;Yielding One&quot;)<br>&nbsp;&nbsp; yield(1)<br>&nbsp;&nbsp; println(&quot;Yielding Two&quot;)<br>&nbsp;&nbsp; yield(2)<br>&nbsp;&nbsp; println(&quot;Yielding Three&quot;)<br>&nbsp;&nbsp; yield(3)</code></pre><p>Notice that the <code>generate</code> construct returns a <code>Seq</code>. Let&#39;s try printing out the items in the sequence.</p><pre><code>println(&quot;The first item in xs is&quot;)<br>println(next(xs))<br>println(&quot;The second item in xs is&quot;)<br>println(next(xs))<br>println(&quot;The third item in xs is&quot;)<br>println(next(xs))</code></pre><p>Compiling and running the above prints out</p><pre><code>The first item in xs is<br>Yielding One<br>1<br>The second item in xs is<br>Yielding Two<br>2<br>The third item in xs is<br>Yielding Three<br>3</code></pre><h3 id="anchor324">The Ability to Resume</h3><p>It&#39;s worth paying attention to the order in which the messages are printed out. The snippet</p><pre><code>println(&quot;The first item in xs is&quot;)<br>println(next(xs))</code></pre><p>by itself, prints out</p><pre><code>The first item in xs is<br>Yielding One<br>1</code></pre><p>Thus the call to <code>next(xs)</code> causes control to enter the block of code in the <code>generate</code> construct. The message <code>&quot;Yielding One&quot;</code> is printed out, and then the call to <code>yield(1)</code> leaves the <code>generate</code> construct and <code>1</code> is the return value of <code>next(xs)</code>.</p><p>The next snippet</p><pre><code>println(&quot;The second item in xs is&quot;)<br>println(next(xs))</code></pre><p>prints out</p><pre><code>The second item in xs is<br>Yielding Two<br>2</code></pre><p>Thus the call to <code>next(xs)</code> causes control to <span style="font-style:italic;">re-enter</span> the block <code>generate</code> construct, resuming from just after the first call to <code>yield</code>. The message <code>&quot;Yielding Two&quot;</code> is printed out, and then the call to <code>yield(2)</code> leaves the <code>generate</code> construct once again and <code>2</code> is the return value of the second call to <code>next(xs)</code>.</p><p>The last snippet</p><pre><code>println(&quot;The third item in xs is&quot;)<br>println(next(xs))</code></pre><p>prints out</p><pre><code>The third item in xs is<br>Yielding Three<br>3</code></pre><p>Similarly, the call to <code>next(xs)</code> resumes the block in the <code>generate</code> construct from just after the second call to <code>yield</code>. The message <code>&quot;Yielding Three&quot;</code> is printed out, and then the call to <code>yield(3)</code> leaves the <code>generate</code> construct once again and <code>3</code> is the return value of the third call to <code>next(xs)</code>.</p><p>Thus the <code>generate</code> construct provides a very convenient way of creating a lazily constructed sequence. </p><h3 id="anchor325">General Form</h3><p>Here is the general form of the <code>generate</code> construct.</p><pre><code>generate&lt;T&gt; :<br>&nbsp;&nbsp; body</code></pre><p><code>generate</code> returns a <code>Seq&lt;T&gt;</code> by lazily executing the given <code>body</code> in a scope containing the generation functions, <code>yield</code> and <code>break</code>. </p><p><code>yield</code> is of type <code>T -&gt; False</code> and its argument becomes an element in the generated <code>Seq</code>. Execution of the generate block pauses at <code>yield</code>, and is resumed on the next call to <code>next</code> on the sequence.</p><p><code>break</code> is both of type <code>() -&gt; Void</code> and <code>T -&gt; Void</code>. If no argument is given to <code>break</code>, then execution of the generate block ends here and marks the end of the generated sequence. If an argument is given to <code>break</code>, then that element is first yielded before the generate block is ended.</p><p>If the generated type, <code>T</code>, is not explicitly provided, then it is assumed to be <code>?</code> by default.</p><h3 id="anchor326">Example: Flattening a Tuple</h3><p>In this example, we&#39;ll determine whether two tuples contain the same elements as each other if we lay out their elements in depth-first order. For example, the tuple</p><pre><code>[[1] [2 [3]] [[4 5] 6]]</code></pre><p>contains the elements <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code> once laid out in depth-first order.</p><p>Here&#39;s the most straightforward way of doing this. We&#39;ll write a function called <code>flatten</code> that returns a <code>Vector</code> containing a tuple&#39;s elements in depth-first order.</p><pre><code>defn flatten (x:Tuple) -&gt; Vector :<br>&nbsp;&nbsp; val v = Vector&lt;?&gt;()<br>&nbsp;&nbsp; defn loop (x) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match(x) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (x:Tuple) : do(loop, x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (x) : add(v, x)<br>&nbsp;&nbsp; loop(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp; v&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></pre><p>Let&#39;s try it out.</p><pre><code>println(flatten([[1] [2 [3]] [[4 5] 6]]))</code></pre><p>Compiling and running the above prints out</p><pre><code>[1 2 3 4 5 6]</code></pre><p>To check whether two tuples contain the same elements, we can just flatten each of them and then compare the elements.</p><pre><code>defn same-elements? (a:Tuple, b:Tuple) :<br>&nbsp;&nbsp; if all?(equal?, flatten(a), flatten(b)) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println(&quot;%_ and %_ have the same elements.&quot; % [a, b])<br>&nbsp;&nbsp; else :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println(&quot;%_ and %_ have different elements.&quot; % [a, b])</code></pre><p>Let&#39;s test it out on the following tuples.</p><pre><code>same-elements?(<br>&nbsp;&nbsp; [[1] [2 [3]] [[4 5] 6]]<br>&nbsp;&nbsp; [1 [[2 3 4] [5]] [6]])<br><br>same-elements?(<br>&nbsp;&nbsp; [[1] [2 [3]] [[4 5] 6]]<br>&nbsp;&nbsp; [[[0] 2] [3 [4 5]] 6])</code></pre><p>Compiling and running the above prints out</p><pre><code>[[1] [2 [3]] [[4 5] 6]] and [1 [[2 3 4] [5]] [6]] have the same elements.<br>[[1] [2 [3]] [[4 5] 6]] and [[[0] 2] [3 [4 5]] 6] have different elements.</code></pre><p>Notice though, that in both cases, we computed a full flattening of both tuples before checking to see whether they are equal. This is obviously inefficient in the second case since we can tell they are clearly different just by examining their first element. How do we avoid computing the full flattening?</p><p>The solution is to <span style="font-style:italic;">lazily</span> compute the flattening. Let&#39;s change <code>flatten</code> to use the <code>generate</code> construct to lazily compute the flattened tuples. To track how much of the tuples are being flattened let&#39;s also add a print statement.</p><pre><code>defn flatten (x:Tuple) -&gt; Seq :<br>&nbsp;&nbsp; val index = to-seq(0 to false)<br>&nbsp;&nbsp; generate :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defn loop (x) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match(x) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (x:Tuple) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do(loop, x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (x) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println(&quot;Yielding Item %_&quot; % [next(index)])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yield(x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></pre><p>Compiling and running the program again prints out</p><pre><code>Yielding Item 0<br>Yielding Item 0<br>Yielding Item 1<br>Yielding Item 1<br>Yielding Item 2<br>Yielding Item 2<br>Yielding Item 3<br>Yielding Item 3<br>Yielding Item 4<br>Yielding Item 4<br>Yielding Item 5<br>Yielding Item 5<br>[[1] [2 [3]] [[4 5] 6]] and [1 [[2 3 4] [5]] [6]] have the same elements.<br>Yielding Item 0<br>Yielding Item 0<br>[[1] [2 [3]] [[4 5] 6]] and [[[0] 2] [3 [4 5]] 6] have different elements.</code></pre><p>Thus the results are the same as before, and you can see that, for the second comparison, both generators (one for each tuple) are only computing up to the first element.</p><h2 id="anchor86">Coroutines</h2><p>The <code>label</code>, <code>attempt</code>, <code>try</code>, and <code>generate</code> constructs are all specific usage patterns of Stanza&#39;s <span style="font-style:italic;">targetable coroutine</span> system. Here we&#39;ll show you how to use the coroutine system in its full generality. It is rare in daily programming to encounter a problem that requires a use of coroutines that isn&#39;t already handled by one of the special case constructs. But for implementing libraries and frameworks that make heavy use of concurrency and non-standard control flow, coroutines may be indispensable. </p><h3 id="anchor327">Sending Things Out</h3><p>Here is the function that will represent our coroutine body.</p><pre><code>defn my-process (co:Coroutine&lt;Int,String&gt;, a:Int) -&gt; String :<br>&nbsp;&nbsp; println(&quot;Passing out Timon&quot;)<br>&nbsp;&nbsp; suspend(co, &quot;Timon&quot;)<br>&nbsp;&nbsp; println(&quot;Passing out and&quot;)<br>&nbsp;&nbsp; suspend(co, &quot;and&quot;)<br>&nbsp;&nbsp; println(&quot;Passing out Pumbaa&quot;)<br>&nbsp;&nbsp; suspend(co, &quot;Pumbaa&quot;)<br>&nbsp;&nbsp; println(&quot;Coroutine is done&quot;)<br>&nbsp;&nbsp; &quot;Done&quot;</code></pre><p>The type <code>Coroutine&lt;Int,String&gt;</code> represents a coroutine for which integers are sent into the coroutine, and for which strings are sent back from the coroutine. The function for sending values out of the coroutine is <code>suspend</code>. </p><p>Let&#39;s now create our coroutine object and resume it a few times.</p><pre><code>println(&quot;Create coroutine&quot;)<br>val co = Coroutine&lt;Int,String&gt;(my-process)<br><br>println(&quot;\nResume with 42&quot;)<br>val x = resume(co, 42)<br>println(&quot;Got back x = %_&quot; % [x])<br><br>println(&quot;\nResume with 43&quot;)<br>val y = resume(co, 43)<br>println(&quot;Got back y = %_&quot; % [y])<br><br>println(&quot;\nResume with 44&quot;)<br>val z = resume(co, 44)<br>println(&quot;Got back z = %_&quot; % [z])<br><br>println(&quot;\nResume with 45&quot;)<br>val w = resume(co, 45)<br>println(&quot;Got back w = %_&quot; % [w])</code></pre><p>Notice that <code>resume</code> is called with integers. When the above is compiled and ran it prints out</p><pre><code>Create coroutine<br><br>Resume with 42<br>Passing out Timon<br>Got back x = Timon<br><br>Resume with 43<br>Passing out and<br>Got back y = and<br><br>Resume with 44<br>Passing out Pumbaa<br>Got back z = Pumbaa<br><br>Resume with 45<br>Coroutine is done<br>Got back w = Done</code></pre><p>Thus <code>suspend</code> acts much like <code>yield</code> did for the <code>generate</code> construct, and <code>resume</code> acts much like <code>next</code> did. This is no accident of course. The <code>generate</code> construct is implemented in terms of <code>suspend</code> and <code>resume</code> underneath.</p><h3 id="anchor328">Breaking Things Off</h3><p>In addition to <code>suspend</code>, a function called <code>break</code> can also be used to send values out of a coroutine. The difference is that a call to <code>break</code> cannot later be resumed.</p><p>Let&#39;s change our <code>my-process</code> function to send out <code>&quot;Pumbaa&quot;</code> with <code>break</code> instead of <code>suspend</code>.</p><pre><code>defn my-process (co:Coroutine&lt;Int,String&gt;, a:Int) -&gt; String :<br>&nbsp;&nbsp; println(&quot;Passing out Timon&quot;)<br>&nbsp;&nbsp; suspend(co, &quot;Timon&quot;)<br>&nbsp;&nbsp; println(&quot;Passing out and&quot;)<br>&nbsp;&nbsp; suspend(co, &quot;and&quot;)<br>&nbsp;&nbsp; println(&quot;Passing out Pumbaa&quot;)<br>&nbsp;&nbsp; break(co, &quot;Pumbaa&quot;)<br>&nbsp;&nbsp; println(&quot;Coroutine is done&quot;)<br>&nbsp;&nbsp; &quot;Done&quot;</code></pre><p>Compiling and running the program again prints out</p><pre><code>Create coroutine<br><br>Resume with 42<br>Passing out Timon<br>Got back x = Timon<br><br>Resume with 43<br>Passing out and<br>Got back y = and<br><br>Resume with 44<br>Passing out Pumbaa<br>Got back z = Pumbaa<br><br>Resume with 45<br>FATAL ERROR: Cannot resume coroutine. Coroutine is already closed.<br>&nbsp;&nbsp; at core/core.stanza:984.13<br>&nbsp;&nbsp; at core/core.stanza:862.16<br>&nbsp;&nbsp; at core/core.stanza:897.40<br>&nbsp;&nbsp; at core/core.stanza:862.16<br>&nbsp;&nbsp; at test.stanza:31.8</code></pre><p>The coroutine is <span style="font-style:italic;">closed</span> after the call to <code>break</code>, and thus our call to <code>resume</code> fails.</p><h3 id="anchor329">Sending Things In</h3><p>The obvious unanswered question now is: what is happening with the <code>42</code>, <code>43</code>, <code>44</code>, and <code>45</code> values that <code>resume</code> is being called with? To answer that, let&#39;s update our <code>my-process</code> function to print out the return values of <code>suspend</code> (and change the call to <code>break</code> back into <code>suspend</code>). </p><pre><code>defn my-process (co:Coroutine&lt;Int,String&gt;, a:Int) -&gt; String :<br>&nbsp;&nbsp; println(&quot;Came in a = %_&quot; % [a])<br>&nbsp;&nbsp; println(&quot;Passing out Timon&quot;)<br>&nbsp;&nbsp; val b = suspend(co, &quot;Timon&quot;)<br><br>&nbsp;&nbsp; println(&quot;Came in b = %_&quot; % [b])<br>&nbsp;&nbsp; println(&quot;Passing out and&quot;)<br>&nbsp;&nbsp; val c = suspend(co, &quot;and&quot;)<br><br>&nbsp;&nbsp; println(&quot;Came in c = %_&quot; % [c])<br>&nbsp;&nbsp; println(&quot;Passing out Pumbaa&quot;)<br>&nbsp;&nbsp; val d = suspend(co, &quot;Pumbaa&quot;)<br><br>&nbsp;&nbsp; println(&quot;Came in d = %_&quot; % [d])<br>&nbsp;&nbsp; println(&quot;Coroutine is done&quot;)<br>&nbsp;&nbsp; &quot;Done&quot;<br><br>println(&quot;Create coroutine&quot;)<br>val co = Coroutine&lt;Int,String&gt;(my-process)<br><br>println(&quot;\nResume with 42&quot;)<br>val x = resume(co, 42)<br>println(&quot;Got back x = %_&quot; % [x])<br><br>println(&quot;\nResume with 43&quot;)<br>val y = resume(co, 43)<br>println(&quot;Got back y = %_&quot; % [y])<br><br>println(&quot;\nResume with 44&quot;)<br>val z = resume(co, 44)<br>println(&quot;Got back z = %_&quot; % [z])<br><br>println(&quot;\nResume with 45&quot;)<br>val w = resume(co, 45)<br>println(&quot;Got back w = %_&quot; % [w])</code></pre><p>Compiling and running the program again prints out</p><pre><code>Create coroutine<br><br>Resume with 42<br>Came in a = 42<br>Passing out Timon<br>Got back x = Timon<br><br>Resume with 43<br>Came in b = 43<br>Passing out and<br>Got back y = and<br><br>Resume with 44<br>Came in c = 44<br>Passing out Pumbaa<br>Got back z = Pumbaa<br><br>Resume with 45<br>Came in d = 45<br>Coroutine is done<br>Got back w = Done</code></pre><p>Thus, <code>suspend</code> sends its argument out from the coroutine, and returns the value sent into the coroutine. <code>resume</code> sends its argument into the coroutine, and returns the value sent out from the coroutine.</p><h3 id="anchor330">Closing Things Off</h3><p>From outside the coroutine body, we may also choose to <span style="font-style:italic;">close</span> a coroutine when we&#39;re finished with it. Let&#39;s try closing our coroutine after getting back <code>&quot;Pumbaa&quot;</code>.</p><pre><code>println(&quot;Create coroutine&quot;)<br>val co = Coroutine&lt;Int,String&gt;(my-process)<br><br>println(&quot;\nResume with 42&quot;)<br>val x = resume(co, 42)<br>println(&quot;Got back x = %_&quot; % [x])<br><br>println(&quot;\nResume with 43&quot;)<br>val y = resume(co, 43)<br>println(&quot;Got back y = %_&quot; % [y])<br><br>println(&quot;\nResume with 44&quot;)<br>val z = resume(co, 44)<br>println(&quot;Got back z = %_&quot; % [z])<br><br>close(co)<br><br>println(&quot;\nResume with 45&quot;)<br>val w = resume(co, 45)<br>println(&quot;Got back w = %_&quot; % [w])</code></pre><p>Compiling and running the above prints out</p><pre><code>Create coroutine<br><br>Resume with 42<br>Came in a = 42<br>Passing out Timon<br>Got back x = Timon<br><br>Resume with 43<br>Came in b = 43<br>Passing out and<br>Got back y = and<br><br>Resume with 44<br>Came in c = 44<br>Passing out Pumbaa<br>Got back z = Pumbaa<br><br>Resume with 45<br>FATAL ERROR: Cannot resume coroutine. Coroutine is already closed.<br>&nbsp;&nbsp; at core/core.stanza:984.13<br>&nbsp;&nbsp; at core/core.stanza:862.16<br>&nbsp;&nbsp; at core/core.stanza:897.40<br>&nbsp;&nbsp; at core/core.stanza:862.16<br>&nbsp;&nbsp; at test.stanza:40.8</code></pre><h3 id="anchor331">Checking a Coroutine's Status</h3><p>There are two functions for checking on the status of a coroutine, <code>active?</code> and <code>open?</code>. </p><p>Calling <code>active?</code> on a coroutine will return <code>true</code> if the coroutine&#39;s body is currently running, and <code>false</code> otherwise. Only active coroutines can be suspended or broken from.</p><p>Calling <code>open?</code> on a coroutine will return <code>true</code> if the coroutine&#39;s body is not currently running and open to be resumed. Only open coroutines can be resumed.</p><h3 id="anchor332">Nested Coroutines</h3><p>A coroutine may also launch more coroutines. Notice that unlike <code>yield</code>, the calls to <code>suspend</code>, <code>break</code>, and <code>resume</code> explicitly requires, as its first argument, the target coroutine. Being able to explicitly designate the target of the <code>suspend</code>, <code>break</code>, and <code>resume</code> operations are key to allowing nested coroutines to work properly.</p><p>Consider the following code, where the coroutine, <code>co1</code>, launches a second coroutine, <code>co2</code>, within its body. Then within <code>co2</code>&#39;s body, there are <code>suspend</code> and <code>break</code> calls on both <code>co1</code> and <code>co2</code>. Pay attention to how this interacts.</p><pre><code>val co1 = Coroutine&lt;False,Int&gt; $ fn (co1, x0) :<br>&nbsp;&nbsp; val co2 = Coroutine&lt;False,False&gt; $ fn (co2, y0) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in 0 to false do :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; suspend(co1, i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if i == 5 :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println(&quot;Breaking from coroutine 2!&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break(co2, false)<br>&nbsp;&nbsp; resume(co2, false)<br>&nbsp;&nbsp; -1<br><br>while open?(co1) :<br>&nbsp;&nbsp; println(resume(co1, false))</code></pre><p>Compiling and running the above prints out</p><pre><code>0<br>1<br>2<br>3<br>4<br>5<br>Breaking from coroutine 2!<br>-1</code></pre><p>The two nested coroutines are quite confusing. To get a better sense of what&#39;s happening, let&#39;s rewrite the second coroutine using the special case <code>label</code> construct.</p><pre><code>val co1 = Coroutine&lt;False,Int&gt; $ fn (co1, x0) :<br>&nbsp;&nbsp; label&lt;False&gt; break :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for i in 0 to false do :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; suspend(co1, i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if i == 5 :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println(&quot;Breaking from coroutine 2!&quot;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break(false)<br>&nbsp;&nbsp; -1<br><br>while open?(co1) :<br>&nbsp;&nbsp; println(resume(co1, false))</code></pre><p>Compiling and running the above prints out the same message as before.</p><p>It is highly unlikely that you will feel the desire to directly launch new coroutines from within other coroutines, as we did here. But this example shows that they nest appropriately and generally <span style="font-style:italic;">do the right thing</span>. Thus, for whatever abstractions you build on top of Stanza&#39;s targetable coroutine system, you can rest assured that they will recurse and compose correctly. </p><h2 id="anchor87">Example: Key Listener</h2><p>The following example demonstrates using coroutines to easily implement a key listener that translates individual key presses into events on strings.</p><p>Let us define a <code>KeyListener</code> type, and its fundamental operation.</p><pre><code>deftype KeyListener<br>defmulti key-pressed (c:Char) -&gt; False</code></pre><p>A <code>KeyListener</code> object listens to individual key presses from a keyboard and translates them into higher level events. Here is the definition of the constructor function for a <code>KeyListener</code>.</p><pre><code>defn KeyListener (entered: String -&gt; False) -&gt; KeyListener</code></pre><p><code>KeyListener</code> takes a callback function called <code>entered</code> that accepts <code>String</code> objects. Our <code>KeyListener</code> translates key presses into calls to <code>entered</code> on space-separated words. It also supports deleting characters with the backspace key, entering of double-quoted strings, and escaped double-quotes within a double-quoted string. Here is specifically what it has to do.</p><ol><li>A <code>KeyListener</code> has an internal buffer for storing characters. When keys corresponding to letters are pressed, they are stored into the internal buffer.
</li><li>When the backspace key is pressed, the last character is deleted from the internal buffer.
</li><li>Once a full word is completed (indicated by the spacebar being pressed), the <code>entered</code> function should be called with the contents of the internal buffer.
</li><li>If the double quote key is pressed, then this indicates that a string is being started, and all subsequent characters until the next double quote should be stored in the internal buffer. Upon completion of the string, the <code>entered</code> function should be called with the entire contents of the internal buffer.
</li><li>During entering of a string, if a backslash character followed by a double quote character is entered, then the double quote character is stored in the internal buffer, and entering of the string continues. If the backslash character is not followed by a double quote then both characters are ignored.
</li></ol><h3 id="anchor333">Coroutine Framework</h3><p>Here is the basic framework that we will use to ease programming the <code>KeyListener</code>.</p><pre><code>defn KeyListener (entered: String -&gt; False) -&gt; KeyListener :<br>&nbsp;&nbsp; val co = Coroutine&lt;Char,False&gt; $ fn (co, c0) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;Retrieve the next character<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defn next-char () :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; suspend(co, false)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br><br>&nbsp;&nbsp; new KeyListener :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod key-pressed (this, c:Char) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resume(co, c)</code></pre><p>We immediately create a coroutine that accepts characters and sends back dummy values of type <code>False</code>. Within the coroutine body, the helper function <code>next-char</code> requests the next character by suspending the coroutine and returning the next character sent back into the coroutine. A new <code>KeyListener</code> object is returned that calls <code>resume</code> on the coroutine whenever a key is pressed.</p><h3 id="anchor334">Buffer Managing Routines</h3><p>The following definitions within the coroutine body help us manage the <code>KeyListener</code>&#39;s internal buffer.</p><pre><code>;Buffer commands<br>val buffer = Vector&lt;Char&gt;()<br>defn pop-char () :<br>&nbsp;&nbsp; if not empty?(buffer) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop(buffer)<br>defn add-char (c:Char) :<br>&nbsp;&nbsp; add(buffer, c)<br>defn empty-buffer () :<br>&nbsp;&nbsp; entered(string-join(buffer))<br>&nbsp;&nbsp; clear(buffer)</code></pre><p>The buffer is represented as a vector of characters. <code>pop-char</code> removes the last character in the buffer if possible. <code>add-char</code> adds the given character to the end of the buffer. <code>empty-buffer</code> calls the <code>entered</code> callback with the contents of the buffer, and then clears the buffer.</p><h3 id="anchor335">Dispatch Mode</h3><p>The key press parser operates in a number of different modes. The default mode is the dispatch mode, which determines which mode to next enter based on the previously pressed key. </p><pre><code>;Dispatch mode<br>defn* parse (c:Char) :<br>&nbsp;&nbsp; if letter?(c) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse-word(c)<br>&nbsp;&nbsp; else if c == &#39;\&quot;&#39; :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse-string(next-char())<br>&nbsp;&nbsp; else :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse(next-char())</code></pre><p>If a letter key was pressed, then we start parsing a word event. If the double-quote key is pressed, then we start parsing a string event. Otherwise, the key press is ignored.</p><h3 id="anchor336">Word Mode</h3><p>The word parsing mode accepts key presses until one word is completed.</p><pre><code>;Word parsing mode<br>defn* parse-word (c:Char) :<br>&nbsp;&nbsp; if letter?(c) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add-char(c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse-word(next-char())<br>&nbsp;&nbsp; else if c == &#39;\b&#39; :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop-char()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse-word(next-char())<br>&nbsp;&nbsp; else if (c == &#39; &#39;) or (c == &#39;\&quot;&#39;) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; empty-buffer()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse(c)<br>&nbsp;&nbsp; else :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse-word(next-char())</code></pre><p>If the last key pressed was a letter, then that letter is added to the buffer. If the last key was a backspace, then we delete a character from the buffer. If the last key was the spacebar or the double-quote key, then the word is completed. We empty the buffer and then go back to the dispatch mode. All other keys are ignored.</p><h3 id="anchor337">String Mode</h3><p>The string parsing mode accepts key presses until another (un-escaped) double-quote key finishes the string.</p><pre><code>;String parsing mode<br>defn* parse-string (c:Char) :<br>&nbsp;&nbsp; if c == &#39;\&quot;&#39; :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; empty-buffer()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse(next-char())<br>&nbsp;&nbsp; else if c == &#39;\b&#39; :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop-char()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse-string(next-char())<br>&nbsp;&nbsp; else if c == &#39;\\&#39; :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if next-char() == &#39;\&quot;&#39; : add-char(&#39;\&quot;&#39;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse-string(next-char())<br>&nbsp;&nbsp; else :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add-char(c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse-string(next-char())</code></pre><p>If the last key pressed was the double-quote key then the string is completed. We empty the buffer and then go back to the dispatch mode. If the last key was a backspace, then we delete a character from the buffer. If the last key was the backslash key, then we add a double-quote to the buffer if the following key is a double-quote. Otherwise both keys are ignored. Finally, all other characters are added to the buffer.</p><h3 id="anchor338">Testing the KeyListener</h3><p>Here is the entire <code>KeyListener</code> constructor function.</p><pre><code>defn KeyListener (entered: String -&gt; False) -&gt; KeyListener :<br>&nbsp;&nbsp; val co = Coroutine&lt;Char,False&gt; $ fn (co, c0) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;Retrieve the next character<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defn next-char () :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; suspend(co, false)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;Buffer commands<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val buffer = Vector&lt;Char&gt;()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defn pop-char () :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not empty?(buffer) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop(buffer)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defn add-char (c:Char) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add(buffer, c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defn empty-buffer () :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; entered(string-join(buffer))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clear(buffer)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;Dispatch mode<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defn* parse (c:Char) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if letter?(c) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse-word(c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if c == &#39;\&quot;&#39; :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse-string(next-char())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse(next-char())<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;Word parsing mode<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defn* parse-word (c:Char) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if letter?(c) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add-char(c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse-word(next-char())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if c == &#39;\b&#39; :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop-char()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse-word(next-char())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (c == &#39; &#39;) or (c == &#39;\&quot;&#39;) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; empty-buffer()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse(c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse-word(next-char())<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;String parsing mode<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defn* parse-string (c:Char) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if c == &#39;\&quot;&#39; :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; empty-buffer()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse(next-char())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if c == &#39;\b&#39; :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop-char()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse-string(next-char())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if c == &#39;\\&#39; :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if next-char() == &#39;\&quot;&#39; : add-char(&#39;\&quot;&#39;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse-string(next-char())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add-char(c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse-string(next-char())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;Launch!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parse(c0)<br><br>&nbsp;&nbsp; new KeyListener :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defmethod key-pressed (this, c:Char) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resume(co, c)</code></pre><p>Let&#39;s try it out on some simulated key presses.</p><pre><code>defn keys-pressed (kl:KeyListener, cs:Seqable&lt;Char&gt;) :<br>&nbsp;&nbsp; do(key-pressed{kl, _}, cs)<br><br>defn main () :<br>&nbsp;&nbsp; val kl = KeyListener $ fn (s) :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; println(&quot;String entered: %_&quot; % [s])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp; ;Test backspace&nbsp;&nbsp; <br>&nbsp;&nbsp; keys-pressed(kl, &quot;Timom\bn &quot;)<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; ;Test simple word<br>&nbsp;&nbsp; keys-pressed(kl, &quot;and &quot;)<br><br>&nbsp;&nbsp; ;Test backspace against empty buffer<br>&nbsp;&nbsp; keys-pressed(kl, &quot;P\b\b\b\bPumbaa&quot;)<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; ;Test unrecognized characters<br>&nbsp;&nbsp; keys-pressed(kl, &quot; a#$!re&quot;)<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; ;Test strings with escaped quotes<br>&nbsp;&nbsp; keys-pressed(kl, \&lt;S&gt;&quot;\&quot;good\&quot; friends!!&quot;&lt;S&gt;)<br><br>main()</code></pre><p>Note that </p><pre><code>\&lt;S&gt;literal !@#$%\|&quot; characters&lt;S&gt;</code></pre><p>is Stanza&#39;s syntax for a literal un-escaped string. All characters between the starting <code>&lt;S&gt;</code> tag and the ending <code>&lt;S&gt;</code> tag are part of the string. Any tag may be used in place of <code>S</code>.</p><p>Compiling and running the above prints out</p><pre><code>String entered: Timon<br>String entered: and<br>String entered: Pumbaa<br>String entered: are<br>String entered: &quot;good&quot; friends!!</code></pre><p>Our <code>KeyListener</code> calls the callback function at the correct times and with the correct input! </p><p>The coroutine mechanism allowed us to keep the code fairly straightforward and modular, even though the logic behind the <code>KeyListener</code> itself is actually quite sophisticated. As an exercise, you may try to implement an equivalent <code>KeyListener</code> function <span style="font-style:italic;">without</span> using the coroutine mechanism to fully appreciate how tedious and error-prone it is.</p>
        </td>
        <td class="rest">
          <img url="resources/spacer.gif"></img>
        </td>
      </tr>
      <tr><td colspan="3" class="footer">
        Site design by Luca Li. Copyright 2015.
      </td></tr>
    </table>
  </body>
</html>
